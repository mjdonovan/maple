writeline(default,"reading function definitions"):
interface(rtablesize=20000):

AdemIndexPairs:=proc(i,j,algtype)
 local ans,s;
 if algtype="u" then
  if i>2*j then
   ans:=[];
   for s from 0 to floor(.5*(i-2*j)-1) do
    if binomial(i-2*j-2-s,s) mod 2=1 then
     ans:=[op(ans),[2*j+1+s,i-j-1-s]];
    fi;
   od;
  else
   ans:=[[i,j]];
  fi;
 elif algtype="Sq1+" then
  if i<=2*j then
   ans:=[];
   for s from 0 to floor(.5*(i-1)) do
    if binomial(j-s-1,i-2*s-1) mod 2=1 then
     ans:=[op(ans),[i+j-s,s]];
    fi;
   od;
  else
   ans:=[[i,j]];
  fi;
 elif algtype="P" then
  if i>=2*j then
   ans:=[];
   for s from i-j+1 to i+j-2 do
    if binomial(2*s-i-1,s-j) mod 2=1 then
     ans:=[op(ans),[i+j-s,s]];
    fi;
   od;
  else
   ans:=[[i,j]];
  fi;
 elif algtype="d" or algtype="dNS" then
  if i<2*j then
   ans:=[];
   for s from ceil((i+1)/2) to floor((i+j)/3) do
    if binomial(j-i+s-1,j-s) mod 2=1 then
     ans:=[op(ans),[i+j-s,s]];
    fi;
   od;
  else
   ans:=[[i,j]];
  fi;
 else
  error "unknown algtype"
 end if;
 ans;
end proc:

MakesSense:=proc(L,algtype)
 local i;
 if algtype="u" or algtype="Sq1+" then
  for i from 1 to nops(L) do
   if type(L[i],nonnegint)=false then
    error "bad entry";
   fi; 
  od;
 elif algtype="P" or algtype="d" or algtype="dNS" then
  for i from 1 to nops(L) do
   if type(L[i]-1,posint)=false then
    error "bad entry";
   fi; 
  od;
 else
  error "unknown algtype"
 end if;
end proc:

IsAdmissible:=proc(L,algtype)
 local i, ans;
 ans:=true;
 if algtype="u" then
  for i from 1 to nops(L)-1 while ans=true do
   if L[i]>2*L[i+1] then
    ans:=i;
   fi;
  end do;  
 elif algtype="Sq1+" then
  for i from 1 to nops(L)-1 while ans=true do
   if L[i]<=2*L[i+1] then
    ans:=i;
   fi;
  end do;  
 elif algtype="P" then
  for i from 1 to nops(L)-1 while ans=true do
   if L[i]>=2*L[i+1] then
    ans:=i;
   fi;
  end do;  
 elif algtype="d" or algtype="dNS" then
  for i from 1 to nops(L)-1 while ans=true do
   if L[i]<2*L[i+1] then
    ans:=i;
   fi;
  end do;  
 else
  error "unknown algtype"
 end if;
 ans;
end proc:

AdemAtLocation:=proc(L,loc,algtype)
 map(AR->[op(L[1..loc-1]),op(AR),op(L[loc+2..nops(L)])],
    AdemIndexPairs(L[loc],L[loc+1],algtype));
end proc:

ListModTwo:=proc(L)
 local ans,i,T;
 T:=ListTools[MakeUnique](L); ans:=[];
 for i from 1 to nops(T) do
  if (numboccur(L,{T[i]}) mod 2)=1 then
   ans:=[op(ans),T[i]];
  fi;
 od;
 ans;
end proc:

AddListsModTwo:=proc(N1:=[],N2:=[],N3:=[],N4:=[],N5:=[],N6:=[],N7:=[])
 ListModTwo([op(N1),op(N2),op(N3),op(N4),op(N5),op(N6),op(N7)])
end proc:

QueueAdem:=proc(seqn,algtype)
 local ADMISlist,q,i,ent,ADM,j,PostReln;
 if nargs>2 then print("input"=seqn);fi;
 ADMISlist:=[]:
 q := queue:-new(seqn):
 for i to 10000 while queue:-length(q)>0 do
  ent:=queue:-dequeue(q);
  ADM:=IsAdmissible(ent,algtype);
  if ADM=true then
   ADMISlist:=[op(ADMISlist),ent];
  else
   PostReln:=AdemAtLocation(ent,ADM,algtype);
   if nargs>2 then print(ent,"inadmissible at",ent[ADM..ADM+1],"giving",nops
(PostReln), "terms");fi;
   for j to nops(PostReln) do
    queue:-enqueue(q,PostReln[j]);
    if nargs>2 then print(PostReln[j]," enqueued");fi;
   od;
  fi;
 end do:
 if nargs>2 then print("if",queue:-length(q)=0,"then have emptied queue and result 
follows");fi;
 ListModTwo(ADMISlist);
end proc:

MinDegree:=proc(L,algtype)
 local ans,shift,i,storeddim;
 if algtype="u" or algtype="Sq1+" or algtype="dNS" then
  shift:=0;
 elif algtype="P" or algtype="d" then
  shift:=1;
 else
  error "unknown algtype"
 end if;
 if nops(L)=0 then
  ans:=-1;
 else
  ans:=L[nops(L)];
  storeddim:=0;
  for i by -1 from nops(L)-1 to 1 do
   storeddim:=storeddim+L[i+1]+shift;
   ans:=max(ans,L[i]-storeddim);
  od;
 fi;
 ans;
end proc:

InternalDegree:=proc(L,algtype)
 local ans;
 if algtype="u" or algtype="Sq1+" or algtype="dNS" or algtype="sum" then
  ans:=sum(L[kakaka],kakaka=1..nops(L));
 elif algtype="P" or algtype="d" then
  ans:=sum(L[kakaka]+1,kakaka=1..nops(L));
 else
  error "unknown algtype"
 end if;
 ans;
end proc:

AllSequences:=proc(s,l,algtype)
 local m;
 if algtype="u" or algtype="Sq1+"  then
  m:=0;
 elif algtype="P" or algtype="d" or algtype="dNS" then
  m:=2;
 else
  error "unknown algtype"
 end if;
 sort(convert(map(xx->map(yy->yy+(m-1),xx),combinat[composition](s-l*(m-1),l)),list));
end proc:

AllSequencesReinvented:=proc(SuM,LengtH,algtype)
 local i,minclass,listo,temp;
 if algtype="u" or algtype="Sq1+"  then
  minclass:=0;
 elif algtype="P" or algtype="d" or algtype="dNS" then
  minclass:=2;
 else
  error "unknown algtype"
 end if;
 if LengtH=1 then
  listo:=[[SuM]];
 else
  listo:=[];
  for i from minclass to SuM-minclass*(LengtH-1) do
   temp:=AllSequencesReinvented(SuM-i,LengtH-1,algtype);
   listo:=[op(listo),op(map(AR->[i,op(AR)],temp))];
  od;
 fi;
 sort(listo);
end proc:

AllAdmissibleSequences:=proc(SuM,LengtH,algtype,prevEntry:=-1)
 local i,minclass,listo,temp;
 if algtype="u" or algtype="Sq1+"  then
  minclass:=0;
 elif algtype="P" or algtype="d" or algtype="dNS" then
  minclass:=2;
 else
  error "unknown algtype"
 end if;
 if LengtH=1 then
  if prevEntry=-1 or IsAdmissible([prevEntry,SuM],algtype)=true then
   listo:=[[SuM]];
  else
   listo:=[];
  fi;
 else
  listo:=[];
  for i from minclass to SuM-minclass*(LengtH-1) do
   if prevEntry=-1 or IsAdmissible([prevEntry,i],algtype)=true then
    temp:=AllAdmissibleSequences(SuM-i,LengtH-1,algtype,i);
    listo:=[op(listo),op(map(AR->[i,op(AR)],temp))];
   fi;
  od;
 fi;
 sort(listo);
end proc:

BarCycle:=proc(II,uOrP)
 local possibleJ,i,j,k,l,ANS,DorSq;
 if uOrP="u" then
  DorSq:="Sq1+";
 elif uOrP="P" then
  DorSq:="d";
 else
  error "need algtype P or u to do Koszul complex"
 end if;
 if IsAdmissible(II,DorSq)<>true then
  error "need Koszul-dual-admissible input"
 fi;
 ANS:=[];
 possibleJ:=AllSequences(InternalDegree(II,"sum"),nops(II),uOrP);
 for i to nops(possibleJ) do
  if (numboccur(II,QueueAdem(possibleJ[i],DorSq)) mod 2)=1 then
   ANS:=[op(ANS),possibleJ[i]];
  fi;
 od;
 sort(map(x->[map(y->[y],x),[]],ANS));
end proc:

BarDifferentialOnMonomial:=proc(b,uOrP)
 local i, ans, compactI, compactF, AdjProduct;
 if nops(b)<>2 or IsAdmissible(b[2],uOrP)<>true then error "b is bad" fi;
 for i from 1 to nops(b[1]) do
  if IsAdmissible(b[1][i],uOrP)<>true then error "b is bad" fi;
 od;
 ans:=[];
 compactI:=[op(b[1]),b[2]];
 for i from 1 to nops(b[1]) do
  AdjProduct:=QueueAdem([op(compactI[i]),op(compactI[i+1])],uOrP);
  compactF:= map(AR->[op(compactI[1..i-1]),(AR),op(compactI[i+2..nops(compactI)])],
    AdjProduct);
  compactF:=map(x->[x[1..nops(x)-1],x[nops(x)]],compactF);
  ans:=[op(ans),op(compactF)];
 od;
 ans;
end proc:

BarDifferential:=proc(B,uOrP)
 sort(ListModTwo(map(x->op(BarDifferentialOnMonomial(x,uOrP)),B)),MprecN);
end proc:

MprecN:=proc(M,N)
 local m,n,ans,i;
 m:=ListTools[FlattenOnce](M[1]);
 n:=ListTools[FlattenOnce](N[1]);
 if nops(m)>nops(n) then
  ans:=true;
 elif nops(m)<nops(n) then
  ans:=false;
 elif m=n then
  ans:=true;
 else
  ans:=5;
  for i from 1 to nops(m) while ans=5 do
   if   m[i]>n[i] then ans:=true
   elif m[i]<n[i] then ans:=false
   fi;
  od;
 fi;
 ans;
end proc:

LengthMinusHomDeg:=proc(M)
 nops(ListTools[FlattenOnce](M[1]))-nops(M[1]);
end proc:

PhiHomotopy:=proc(B,uOrP)
 local Bs,ms,num,i,j,ans,b,stillsingle,b1is,newb1,goforit;
 ans:=[];
 Bs:=sort(B,MprecN);
 ms:=map(x->ListTools[FlattenOnce](x[1]),Bs);
 if nops(B)=0 or nops(ms[1])=nops(Bs[1][1]) then
  print("done, dummy!");
  ans:=[];
 else
  num:=numboccur(ms,{ms[1]});
  for i from 1 to num do
   b:=Bs[i];
   stillsingle:=true;
   b1is:=[];
   for j from 1 to nops(b[1]) while stillsingle=true do
    b1is:=[op(b1is),[b[1][j][1]]];
    if nops(b[1][j])>1 then stillsingle:=false; fi;
   od;
   if uOrP="P" and IsAdmissible(ListTools[FlattenOnce](b1is),"d")=true then goforit:=true
   elif uOrP="u" and IsAdmissible(ListTools[FlattenOnce](b1is),"Sq1+")=true then goforit:=true
   else goforit:=false; fi;
   if goforit=true then
    newb1:=[op(b1is),b[1][nops(b1is)][2..nops(b[1][nops(b1is)])],
      op(b[1][nops(b1is)+1..nops(b[1])])];
    ans:=[op(ans),[newb1,b[2]]];
   fi;
  od;
 fi;
 ans;
end proc:

dPhi:=proc(B,uOrP)
 sort(BarDifferential(PhiHomotopy(B,uOrP),uOrP),MprecN);
end proc:

ADDdPhi:=proc(B,uOrP)
 sort(AddListsModTwo(B,BarDifferential(PhiHomotopy(B,uOrP),uOrP)),MprecN);
end proc:

RestrictionOfMuI:=proc(II,cDim)
 local i,ans,temp,topUdim,uII;
 if IsAdmissible(II,"Sq1+")<>true then error "not u-admissible" fi;
 if MinDegree(II,"u")>=cDim then error "not only nontop u" fi;
 if cDim<0 then error "negative dimensional class? really?" fi;
 ans:=[];
 topUdim:=cDim+InternalDegree(II,"u");
 uII:=BarCycle(II,"u");
 for i to nops(uII) do
  temp:=AdemIndexPairs(topUdim,uII[i][1][1][1],"u");
  temp:=map(a->[[a,op(uII[i][1][2..nops(uII[i][1])])],uII[i][2]],temp);
  ans:=[op(ans),op(temp)];
 od;
 sort(ListModTwo(ans),MprecN);
end proc:

RepeatedHomotopy:=proc(B,maxTries,uOrP)
 local i,T;
 T:=sort(B,MprecN);
 for i to maxTries while LengthMinusHomDeg(T[1])>0 do
  T:=ADDdPhi(T,uOrP);
 od;
 #if LengthMinusHomDeg(T[1])=0 then print(DONE); fi;
 T;
end proc:

MprecNalt:=proc(M,N)
 local ans,i;
 if nops(M[2])<nops(N[2]) then
  ans:=true;
 elif nops(M[2])>nops(N[2]) then
  ans:=false;
 elif M[2]=N[2] then
  ans:=MprecN(M,N)
 else
  ans:=5;
  for i from nops(M[2]) to 1 by -1 while ans=5 do
   if   M[2][i]<N[2][i] then ans:=true
   elif M[2][i]>N[2][i] then ans:=false
   fi;
  od;
 fi;
 ans;
end proc:

SqCompsMLi:=proc(M,L,i1min)
  local shifter,i;
  shifter:=[i1min-1];
  for i to L-1 do shifter:=[0,op(shifter)];od;
  map(xx->xx+shifter,combinat[composition](M-(i1min-1), L));
end proc:
SqCompsMi:=proc(M,i1min)
  local ans,L;
  ans:=[];
  for L from 1 to M-i1min+1 do
    ans:=[op(ans),op(SqCompsMLi(M,L,i1min))];
  od;
  ans;
end proc:

SqCompM:=proc(comp)
 sum(comp[k],k=1..nops(comp));
end proc:
SqCompN:=proc(comp)
 sum((2^k-1)*comp[k],k=1..nops(comp));
end proc:

delAdmissables:=proc(maxLength,d)
 local ADMISlist,AMLcount,q,i,ent,j,PostReln;
 ADMISlist:=Table(): AMLcount:=0:
 q := queue:-new([]):
 for i to 10000 while queue:-length(q)>0 do
  ent:=queue:-dequeue(q);
  AMLcount:=AMLcount+1:
  ADMISlist[AMLcount]:=ent;
  if(nops(ent)<maxLength) then
   for j from (sum(ent[k],k=1..nops(ent))+nops(ent)+d) to `if`(nops(ent)>0,2*ent[1],2) by -1 do   
    queue:-enqueue(q,[j,op(ent)]);
   od;
  fi;
 od:
 [seq(ADMISlist[j],j=1..AMLcount)];
end proc:

delAdmissablesByMaxSum:=proc(maxSum,d)
 local ADMISlist,AMLcount,q,i,ent,j,PostReln,sumSoFar;
 ADMISlist:=Table(): AMLcount:=0:
 q := queue:-new([]):
 if maxSum>2000 or d>2 then 
  UserFeedback("you've called delAdmissablesByMaxSum(",maxSum,",",d,")... is 50000 still enough iterations?");
 fi;
 for i to 50000 while queue:-length(q)>0 do
  ent:=queue:-dequeue(q);
  AMLcount:=AMLcount+1:
  ADMISlist[AMLcount]:=ent;
  sumSoFar:=sum(ent[k],k=1..nops(ent));
  for j from min(maxSum-sumSoFar,(sumSoFar+nops(ent)+d)) 
          to `if`(nops(ent)>0,2*ent[1],2) by -1 do   
   queue:-enqueue(q,[j,op(ent)]);
  od;
 od:
 print(i);
 [seq(ADMISlist[j],j=1..AMLcount)];
end proc:

I1vulnerable:=proc(I1,d)
 local ans;
 ans:=0;
 if nops(I1)>2 then
  if I1[1]=sum(I1[jJki],jJki=2..nops(I1))+d+nops(I1)-1 then
   ans:=1;
  fi;
 fi;
 ans;
end proc:

I2vulnerable:=proc(I2)
 local ans;
 ans:=0;
 if nops(I2)=0 or I2[nops(I2)]>2 then
  ans:=1;
 fi;
 ans;
end proc:

Esatisfied:=proc(I1,I2,d)
 I1vulnerable(I1,d)* I2vulnerable(I2);
end proc:

multiDimension:=proc(S,d)
 local i,ans,ellR,ennR,N,smr;
 N:=nops(S);ellR:=[];ennR:=[];
 ellR:=map(x->nops(x),S);
 ennR:=map(x->sum(x[smr],smr=1..nops(x)),S);
 ans:=[0,op(ennR)]+[op(ellR),1+ellR[N]+d];
 for i from 3 to N+1 do
  ans[i]:=ans[i]*2^(sum(ellR[smr],smr=1..i-2));
 od;
 ans[N+1]:=ans[N+1]-1;
 ans;
end proc:

multiDimensionAdjusted:=proc(S,d)
 #adjusted so that all but the final entry are inputted in excess-vector format
 local i,ans,ellR,ennR,N,smr;
 N:=nops(S);ellR:=[];ennR:=[];
 ellR:=map(x->nops(x),S);
 ennR:=map(x->add(x[smr+1]*(2^(smr+1)-1),smr=0..nops(x)-1),S);
 ennR[N]:=sum(S[N][smr],smr=1..nops(S[N]));
 ans:=[0,op(ennR)]+[op(ellR),1+ellR[N]+d];
 for i from 3 to N+1 do
  ans[i]:=ans[i]*2^(sum(ellR[smr],smr=1..i-2));
 od;
 ans[N+1]:=ans[N+1]-1;
 ans;
end proc:

tMINUSsAdjusted:=proc(S,d)
 multiDimensionAdjusted(S,d);
 %[nops(%)]-add(%[j],j=1..nops(%)-1);
end proc:

E2DegreeIndecElt:=proc(S,d)
 [0,op(multiDimensionAdjusted(S,d))];
end proc:

E2DegreePRHomElt:=proc(HE,d)
 local ans;
 ans:=[add(HE[r][1],r=1..nops(HE))-1,0,op(add(HE[i][1]*multiDimensionAdjusted(HE[i][2],d),i=1..nops(HE)))];
 ans[nops(ans)]:=ans[nops(ans)]+ans[1];
 ans;
end proc:

E2DegreePRHomEltNoZero:=proc(HE,d)
 remove(x->x=0,E2DegreePRHomElt(HE,d));
end proc:
Swhat:=proc(elt,d)
 local i,N,T,ans;
 N:=nops(elt);
 T:=add(nops(elt[i]),i=1..N);
 ans:=3; 
 if T>2 then
  ans:=3;
 elif T=0 then
  ans:=0;
 elif T=1 then
  ans:=1;
 elif nops(elt[N])=2 and elt[N][1]=elt[N][2]+d+1 then
  ans:=2;
 fi;
 ans;
end proc:

I1DecomposableTest:=proc(I1,d)
 local ans;
 ans:=0;
 if nops(I1)>1 and I1[1]=sum(I1[jJki],jJki=2..nops(I1))+d+nops(I1)-1 then
   1;
else 0 fi;
end proc:

TrimSListBYst:=proc(sL,smax,tmax,d)
 local ans,i,j,Dm,S,T;
 ans:=[];
 for i to nops(sL) do
  Dm:=multiDimensionAdjusted(sL[i],d);
  S:=add(Dm[j],j=1..nops(Dm)-1);
  T:=Dm[nops(Dm)];
  if T<=tmax and S<=smax then
   ans:=[op(ans),sL[i]];
  fi;
 od;
 ans;
end proc:
TrimSListBYtMINUSs:=proc(sL,tMINUSs,d)
 local ans,i,j,Dm,S,T;
 ans:=[];
 for i to nops(sL) do
  Dm:=multiDimensionAdjusted(sL[i],d);
  S:=add(Dm[j],j=1..nops(Dm)-1);
  T:=Dm[nops(Dm)];
  if T-S=tMINUSs then
   ans:=[op(ans),sL[i]];
  fi;
 od;
 ans;
end proc:
TrimSListBYtMINUSsAndNovelty:=proc(sL,tMINUSs,d)
 local ans,i,j,Dm,S,T;
 ans:=[];
 for i to nops(sL) do
  Dm:=multiDimensionAdjusted(sL[i],d);
  S:=add(Dm[j],j=1..nops(Dm)-1);
  T:=Dm[nops(Dm)];
  if T-S=tMINUSs and Dm[1]>0 then
   ans:=[op(ans),sL[i]];
  fi;
 od;
 ans;
end proc:

TrimPRHomologyListBYst:=proc(sL,smax,tmax,d)
 local ans,i,j,Dm,S,T;
 ans:=[];
 for i to nops(sL) do
  Dm:=E2DegreePRHomElt(sL[i],d);
  S:=add(Dm[j],j=1..nops(Dm)-1);
  T:=Dm[nops(Dm)];
  if T<=tmax and S<=smax then
   ans:=[op(ans),sL[i]];
  fi;
 od;
 ans;
end proc:
TrimPRHomologyListBYtMINUSs:=proc(sL,tMINUSs,d)
 local ans,i,j,Dm,S,T;
 ans:=[];
 for i to nops(sL) do
  Dm:=E2DegreePRHomElt(sL[i],d);
  S:=add(Dm[j],j=1..nops(Dm)-1);
  T:=Dm[nops(Dm)];
  if T-S=tMINUSs then
   ans:=[op(ans),sL[i]];
  fi;
 od;
 ans;
end proc:

TrimPRHomologyListBYtMINUSsAndNovelty:=proc(sL,tMINUSs,d)
 local ans,i,j,Dm,S,T;
 ans:=[];
 for i to nops(sL) do
  Dm:=E2DegreePRHomElt(sL[i],d);
  S:=add(Dm[j],j=1..nops(Dm)-1);
  T:=Dm[nops(Dm)];
  if T-S=tMINUSs and IsX00or00X(Dm)=0 then
   ans:=[op(ans),sL[i]];
  fi;
 od;
 ans;
end proc:

Is00:=proc(L)
 local ans;
 ans:=0;
 if nops(L)>1 and L[1]=0 and L[2]=0 then
  ans:=1;
 fi;
 ans;
end proc: 

IsX00:=proc(L)
 local ans;
 ans:=0;
 if nops(L)>2 and L[3]=0 and L[2]=0 then
  ans:=1;
 fi;
 ans;
end proc: 

IsX00or00X:=proc(L)
 local ans;
 ans:=0;
 if nops(L)>2 and L[3]=0 and L[2]=0 then
  ans:=1;
 fi;
 if nops(L)>1 and L[1]=0 and L[2]=0 then
  ans:=1;
 fi;
 ans;
end proc: 

PRHomologyIterator:=proc(s01,s2,s3,shorterOnes,maxL)
 local ans,numShrt,i,j,ToIns,pos,r;
 ans:=shorterOnes;numShrt:=nops(ans);
 for i to numShrt do
  for j to nops(s01) do
   if ListTools[Search](s01[j],map(x->x[2],ans[i]))=0 then
    ToIns:=sort([op(ans[i]),[1,s01[j]]]);
    if add(ToIns[r][1],r=1..nops(ToIns))<=maxL and ListTools[Search](ToIns,ans)=0 then
     ans:=[op(ans),ToIns];
    fi;
   fi;
  od;
  for j to nops(s2) do
   pos:=ListTools[Search](s2[j],map(x->x[2],ans[i]));
   if pos=0 then
    ToIns:=sort([op(ans[i]),[2,s2[j]]]);
   else
    ToIns:=ans[i];
    ToIns[pos][1]:=ToIns[pos][1]+2;
    ToIns:=sort(ToIns);
   fi;
   if add(ToIns[r][1],r=1..nops(ToIns))<=maxL and ListTools[Search](ToIns,ans)=0 then
    ans:=[op(ans),ToIns];
   fi;
  od;
  for j to nops(s3) do
   pos:=ListTools[Search](s3[j],map(x->x[2],ans[i]));
   if pos=0 then
    ToIns:=sort([op(ans[i]),[1,s3[j]]]);
   else
    ToIns:=ans[i];
    ToIns[pos][1]:=ToIns[pos][1]+1;
    ToIns:=sort(ToIns);
   fi;
   if add(ToIns[r][1],r=1..nops(ToIns))<=maxL and ListTools[Search](ToIns,ans)=0 then
    ans:=[op(ans),ToIns];
   fi;
  od;
 od;
 ans;
end proc:

PrettyPrintSequence:=proc(KE)
local ANS,i,symbls;
 symbls:=[delta,SQa,SQb,SQc,SQd,SQe,SQf,SQg,SQh,SQi,SQj,SQk,SQl,SQm,
                SQn,SQo,SQp,SQq,SQr,SQs,SQt,SQu,SQv,SQw,SQx,SQy,SQz];
 ANS:='e':
 for i from nops(KE) to 1 by -1 do 
  if nops(KE[i])>0 then 
   ANS:=symbls[1+nops(KE)-i][op(KE[i])]*ANS;
  fi;
 od;
 ANS; 
end proc:

PrettyPrintPRelt:=proc(PRelt)
 local ANSr,i;
 if nops(PRelt)>0 then
  ANSr:=omega[PRelt[nops(PRelt)][1]](PrettyPrintSequence(PRelt[nops(PRelt)][2]));
  for i from nops(PRelt)-1 to 1 by -1 do
   ANSr:=omega[PRelt[i][1]](PrettyPrintSequence(PRelt[i][2]))*ANSr;
  od;
 else ANSr:=1;
 fi;
 ANSr;
end proc:

PRHomologyListNovelData:=proc(sL,d)
 local ans,i,j,Dm,S,T;
 ans:=[];
 for i to nops(sL) do
  Dm:=E2DegreePRHomElt(sL[i],d);
  S:=add(Dm[j],j=1..nops(Dm)-1);
  T:=Dm[nops(Dm)];
  if IsX00(Dm)=0 and Dm[1]>-1 then
   ans:=[op(ans),["PR",sL[i],PrettyPrintPRelt(sL[i]),T-S,Dm]];
  fi;
 od;
 ans;
end proc:

IndecListNovelData:=proc(sL,d)
 local ans,i,j,Dm,S,T;
 ans:=[];
 for i to nops(sL) do
  Dm:=multiDimensionAdjusted(sL[i],d);
  S:=add(Dm[j],j=1..nops(Dm)-1);
  T:=Dm[nops(Dm)];
  if Dm[1]>0 then
   ans:=[op(ans),["Ind",sL[i],PrettyPrintSequence(sL[i]),T-S,Dm]];
  fi;
 od;
 ans;
end proc:

CollapseDimensions:=proc(Dm)
 local ans,i,deeT;
 deeT:=Dm;
 ans:=[Dm];
 for i to nops(Dm)-2 do
  deeT:=[deeT[1]+deeT[2],op(deeT[3..nops(deeT)])];
  ans:=[op(ans),deeT];
 od:
 [op(ans),[deeT[2]-deeT[1]]];
end proc:

PrintNData:=proc(inp)
 print(inp[3],"    ",op(map(x->([E[op(x)]]),CollapseDimensions(inp[5]))));
end proc:

ToInsTmS:=proc(ToIns,d)
 E2DegreePRHomElt(ToIns,d);
 %[nops(%)]-add(%[j],j=1..nops(%)-1);
end proc:

PRHomologyIteratorExtraSmart:=proc(s01,s2,s3,shorterOnes,maxTmS,d)
 local ans,numShrt,i,j,ToIns,pos,r;
 ans:=[];numShrt:=nops(shorterOnes);
 for i to numShrt do
  for j to nops(s01) do
   if ListTools[Search](s01[j],map(x->x[2],shorterOnes[i]))=0 then
    ToIns:=sort([op(shorterOnes[i]),[1,s01[j]]]);
    if ToInsTmS(ToIns,d)<=maxTmS and ListTools[Search](ToIns,shorterOnes)=0 then
     ans:=[op(ans),ToIns];
    fi;
   fi;
  od;
  for j to nops(s2) do
   pos:=ListTools[Search](s2[j],map(x->x[2],shorterOnes[i]));
   if pos=0 then
    ToIns:=sort([op(shorterOnes[i]),[2,s2[j]]]);
   else
    ToIns:=shorterOnes[i];
    ToIns[pos][1]:=ToIns[pos][1]+2;
    ToIns:=sort(ToIns);
   fi;
   if ToInsTmS(ToIns,d)<=maxTmS and ListTools[Search](ToIns,shorterOnes)=0 then
    ans:=[op(ans),ToIns];
   fi;
  od;
  for j to nops(s3) do
   pos:=ListTools[Search](s3[j],map(x->x[2],shorterOnes[i]));
   if pos=0 then
    ToIns:=sort([op(shorterOnes[i]),[1,s3[j]]]);
   else
    ToIns:=shorterOnes[i];
    ToIns[pos][1]:=ToIns[pos][1]+1;
    ToIns:=sort(ToIns);
   fi;
   if ToInsTmS(ToIns,d)<=maxTmS and ListTools[Search](ToIns,shorterOnes)=0 then
    ans:=[op(ans),ToIns];
   fi;
  od;
 od;
 ans;
end proc:

PromotePRList:=proc(PRList)
 map(EG->map(EGr->[EGr[1],[[],op(EGr[2])]],EG),PRList);
end proc:

UserFeedback:=proc()
 local ans,i,Listo;Listo:=[args];
 ans:="";
 for i to nops(Listo) do
  ans:=cat(ans,convert(Listo[i],'string'));
 od;
 writeline(default,ans);
 NULL;
end proc:

ExcessFormatToStandard:=proc(Listo,AmIOn:=1)
 local ans,i;
 if AmIOn>0 then
  ans:=[];
  if nops(Listo)>0 then
   ans:=[Listo[nops(Listo)]];
   for i from nops(Listo)-1 to 1 by -1 do
    ans:=[ans[1]*2+Listo[i],op(ans)];
   od;
  fi;
 else ans:=Listo; fi;
 ans;
end proc:

RemoveFromList:=proc(e,L)
 local s;
 s:=remove(x->x=e,L);
 if nops(L)=nops(s) then
  error "didn't find the element to be removed";
 fi;
 s;
end proc:

AddToList:=proc(e,L)
 if ListTools[Search](e,L)<>0 then
  error "element already in list";
 else
  [op(L),e];
 fi;
end proc:

testIfObviouslyLivesToEinfty:=proc(PRE)
#looks for things detecting divided powers of the fundamental class
 local i,j,k,ans;
 ans:=1;
 for i in PRE while ans=1 do
  if i[1]<>1 or nops(remove(x->x=[],i[2]))>1 or 
  i[2][nops(i[2])]<>[8192,4096,2048,1024,512,256,128,64,32,16,8,4,2][14-nops(i[2][nops(i[2])])..-1]
  then
   ans:=0
  fi;
 od;
 ans;
end proc:

PRIter:=proc(STATZ,maxTmS)
 local ans, newbs, stat, base, olCount, i, j;
 ans:=[[[],0]];
 for j to nops(STATZ) do
  stat:=STATZ[j];
  newbs:=[];
  for base in ans while base[2]+stat[2]*stat[3]<=maxTmS do
   for i to `if`(stat[1]="poly",floor((maxTmS-base[2])/(stat[2]*stat[3])),1) do
    newbs:=[op(newbs),[[op(base[1]),[i*stat[2],j]],base[2]+i*stat[2]*stat[3]]];
   od;
  od;
  ans:=sort([op(ans),op(newbs)],(x,y)->x[2]<y[2]);
 od;
 subsop(1=NULL,ans);
end proc:

Finder:=proc(elt,S4L)
#searches S4List to find the number of a given element
 local i,E;
 E:=elt;
 for i to nops(S4L[1]) while nops(E)<nops(S4L[1]) do
  E:=[[],op(E)]
 od;
 i:=ListTools[Search](E,S4L);
 if i=0 then 
  error cat("not found",elt);
 fi;
 i;
end proc:

FinderNoErrors:=proc(elt,S4L)
#searches S4List to find the number of a given element
 local i,E;
 E:=elt;
 for i to nops(S4L[1]) while nops(E)<nops(S4L[1]) do
  E:=[[],op(E)]
 od;
 return ListTools[Search](E,S4L);
end proc:

Replacer:=proc(seq,newstats,S4L,statz)
 local ans,i;
 ans:=statz;
 i:=Finder(seq,S4L);
 ans:=subsop(i=[newstats[1],newstats[2],statz[i][3]],ans);
 UserFeedback("Replaced stats for ",seq,", so that ",statz[i],"~~>",ans[i]);
 ans;
end proc:

difl:=proc(ctr,diffName,sSeqEX,sPow,tSeqEX,tPow,L,S,ctrMax,PostMessage:=".")
#S:=difl(n,"dwhat",sSeqEX,sPow,tSeqEX,tPow,L,S,Mctr):
#input: 3-6: a source and target sequence and their powers
#       7-8: sequence and stats lists
#       1-2: a number and differential name identifying the diff
#         9: maximum number we'll evaluate on
#output: the stats list after implementing the differential
 local sPos,tPos,sSeq,tSeq,i,j,k,sIS,tIS,sFS,tFS,ansS;
 sSeq:=unExcessFormatSeq(sSeqEX);
 tSeq:=unExcessFormatSeq(tSeqEX);
 if diffName<>"dwhat" and ctr<=ctrMax then
  sPos:=Finder(sSeq,L):
  sIS:=S[sPos];
  tPos:=Finder(tSeq,L):
  tIS:=S[tPos];
  if sIS[1..2]<>["poly",sPow] then
   error "can't deal with this kind of source";
  fi;
  if tIS[1..2]<>["poly",tPow] and tIS[1..2]<>["poly",tPow/2] then
   error "can't deal with this kind of target";
  fi;
  sFS:=["poly",2*sIS[2],sIS[3]];
  tFS:=["ext",`if`(tPow=tIS[2],1000,tIS[2]),tIS[3]];
  if PostMessage<>"quiet" then
   UserFeedback(ctr,". ",diffName,":",sSeqEX,"^",sPow,"~~>",tSeqEX,"^",tPow,
   " (stem:",sIS[2]*sIS[3],"~~>",tIS[3]*tPow,", src:poly",sIS[2],"->poly",
   sFS[2],", trg:poly",tIS[2],"->ext",tFS[2],")",PostMessage);
  fi;
  return subsop(sPos=sFS,tPos=tFS,S);
 else return S;
 fi;
end proc:


OutputMatrix:=proc(S,L,calcToDimension,OutputFileSuffix,voLume:="loud")
 local PRITs,subinseqs,ALLND,ALLNDbrief,i;
 PRITs:=PRIter(S,calcToDimension):
 subinseqs:=map(x->[map(y->[y[1],L[y[2]]],x[1]),x[2]],PRITs):
 subinseqs:=remove(x->testIfObviouslyLivesToEinfty(x[1])=1,subinseqs):
 ALLND:=map(XXX->["PR",ExcessFormatPR(XXX[1]),PrettyPrintPRelt(ExcessFormatPR(XXX[1])),
                  XXX[2],E2DegreePRHomEltNoZero(XXX[1],dValue)],subinseqs):
 ALLND:=sort(ALLND,(x,y)->(x[4]<y[4] or 
                           (x[4]=y[4] and x[5][-1]<y[5][-1])) or
                           (x[4]=y[4] and x[5][-1]=y[5][-1] and
  lexorder(StringTools[Reverse](convert(ListTools[Flatten](x[2][1][2]),string)),
           StringTools[Reverse](convert(ListTools[Flatten](y[2][1][2]),string)))
                            )):
 if voLume="3col" or voLume="3colLoud" then
  ALLNDbrief:=map(inp->[`if`(nops(inp[2])=1,[remove(x->x=[],inp[2][1][2]),inp[2][1][1]],""),inp[3],(map(x->(`if`(nops(x)=1, pi[x[1]], E[op(x)])),(CollapseDimensions(inp[5]))))],ALLND): 
  if nops(ALLNDbrief)<99 then 
   for i to nops(ALLNDbrief) do
    ALLNDbrief[i]:=[i,op(ALLNDbrief[i]),add(ALLND[i][5][j],j=1..nops(ALLND[i][5])-1)]
   od;
  fi;
 else
  ALLNDbrief:=map(inp->[inp[3],(map(x->(`if`(nops(x)=1, pi[x[1]], E[op(x)])),(CollapseDimensions(inp[5]))))],ALLND): 
 fi;
 if OutputFileSuffix=0 or OutputFileSuffix="FileSuffixHere" then
  print(Matrix(ALLNDbrief));
 else
  latex(Matrix(ALLNDbrief),cat("C:/Users/Michael/Desktop/latexForTables/tableRawData",OutputFileSuffix,".tex"));
 if voLume="loud" or voLume="3colLoud" then UserFeedback("output saved to ",
              cat("C:/Users/Michael/Desktop/latexForTables/tableRawData",OutputFileSuffix,".tex")); fi;
 fi:
 if voLume="loud" or voLume="3colLoud" then 
  UserFeedback(time(),"s: calculated ",nops(ALLNDbrief)," elements up to the ",calcToDimension,"-stem");
 fi:
 if voLume="3col" or voLume="3colLoud" then
  return Matrix(ALLNDbrief);
 fi;
end proc:

diffExtractor:=proc(TR,SR,OM,AllMods)
 print(LinearAlgebra[SubMatrix](OM,[TR,SR],[1..-1]));
 [AllMods[-1][1]+1,cat("d",OM[TR,5]-OM[SR,5]),op(OM[SR,2]),op(OM[TR,2])];
end proc:

constructSandL:=proc(calcToDimension,dValue)
 local sMax,tMax,l1Max,SqList,I2SqList,M,I2ListByM,I3ListByM,
       S1ListIgnoreE,S1List,S2List,S3List,i,j,m2,m,S4List,
       istatz,LL,TEMPS,IT,oldList,newList;
 sMax:=floor(calcToDimension*4/5-1):
 tMax:=floor(calcToDimension*9/5-1):
 l1Max:=floor(log[2](tMax-dValue+1)):

 UserFeedback("Calculating initial S and L, up to the ",calcToDimension,"-stem on the ",dValue,"-sphere");
 SqList:=[[[]],[[0]]]:
 for M from 1 to 11 do
  SqList:=[op(SqList),[op(SqCompsMi(M,0))]];
 od:
 I2SqList:=[[[]],[]]:
 for M from 1 to 11 do
  I2SqList:=[op(I2SqList),[op(SqCompsMi(M,2))]];
 od:
 I2ListByM:=x->I2SqList[x+2]:
 I3ListByM:=x->SqList[x+2]:
 
 UserFeedback("calculating SNList:=S^(N)");
 S1ListIgnoreE:=map(x->[x],delAdmissables(l1Max,dValue)):
 S1ListIgnoreE:=TrimSListBYst(S1ListIgnoreE,sMax,tMax,dValue):
 S1List:=remove(x->I1vulnerable(x[1],dValue)>0,S1ListIgnoreE):
 S1List:=TrimSListBYst(S1List,sMax,tMax,dValue):
 UserFeedback("S1List has ",nops(S1List)," elements");
 S2List:=[]:
 for i from 1 to nops(S1ListIgnoreE) do
  for m2 from -1 to nops(S1ListIgnoreE[i][1])-1 do
   for j from 1 to nops(I2ListByM(m2)) do
    if Esatisfied(S1ListIgnoreE[i][1],I2ListByM(m2)[j],dValue)=0 then 
     S2List:=[op(S2List),[I2ListByM(m2)[j],op(S1ListIgnoreE[i])]];
    fi;
   od;
  od;
 od;
 S2List:=TrimSListBYst(S2List,sMax,tMax,dValue):
 UserFeedback("S2List has ",nops(S2List)," elements");
 oldList:=[];newList:=S2List; 
 for IT from 3 to 20 while nops(oldList)<>nops(newList) do
  oldList:=newList;newList:=[];
  for i in oldList do
   for m from -1 to nops(i[1])-1 do
    for j in I3ListByM(m) do
     newList:=[op(newList),[j,op(i)]];
    od;
   od;
  od;
  newList:=TrimSListBYst(newList,sMax,tMax,dValue):
  UserFeedback("S",IT,"List has ",nops(newList)," elements");
 od;
 oldList:=map(x->[x,tMINUSsAdjusted(x,dValue)],oldList);
 oldList:=sort(oldList,(x,y)->x[2]<y[2]);
 istatz:=map(x->["poly",1,x[2]],oldList):
#USED TO HAVE SOMETHING LIKE
#  if TEMPS<2 then
#   istatz:=[op(istatz),["ext",1,tMINUSsAdjusted(LL,dValue)]];
#  elif TEMPS=2 then
#   istatz:=[op(istatz),["poly",2,tMINUSsAdjusted(LL,dValue)]];
#  elif TEMPS=3 then
#   istatz:=[op(istatz),["poly",1,tMINUSsAdjusted(LL,dValue)]];
#  fi;
#IMPORTANT VARIATION HERE - I've allowed S_1 and S_2 to fold in to
#S_3, so that all generators start out polynomial. Then the generators
#involved get an easy differential thereupon which does the job.
 oldList:=map(x->x[1],oldList):
 if remove(x->x=[],oldList[1])<>[] then
  error cat("oldlist[1] isn't the fundamental class: ",oldList[1]);
 fi;
 return [subsop(1=["ext",1,dValue],istatz),oldList];
end proc:

BDimFind:=proc(S,L)
 local i,j,mindim,K;
 mindim:=1000;
 for i to nops(S) do
  K:=L[i];
  if (nops(remove(x->x=[],K))<=1 and K[nops(K)]=[8192,4096,2048,1024,512,256,128,64,32,16,8,4,2][14-nops(K[nops(K)])..-1]) then
   if S[i][1]="poly" then
    mindim:=min(mindim,max(2,S[i][2])*S[i][3]);
   fi;
   if S[i][1]="ext" then
    #mindim:=min(mindim,max(2,S[i][2])*S[i][3]);
   fi;
  else
   mindim:=min(mindim,S[i][2]*S[i][3]);
  fi;
 od;
 mindim;
end proc:

SimpleDiffBuilder:=proc(src,SS,dValue)
 local b,tar,bfound,tarfound,tarpow;
 if nops(remove(x->x=[],src))<>1 or SS[2]<>1 or src[nops(src)]=[8192,4096,2048,1024,512,256,128,64,32,16,8,4,2][14-nops(src[nops(src)])..-1] 
  then return 0; fi;
 tar:=[[b],src[-1][2..-1]];
 bfound:=solve(0=tMINUSsAdjusted(tar,dValue)-(tMINUSsAdjusted(src,dValue)-1),b);
 if bfound>nops(src[-1])-1 then
  error "WTF";
 elif bfound=nops(src[-1])-1 then
  tarfound:=[src[-1][2..-1]]; tarpow:=2;
 else
  tarfound:=[[bfound],src[-1][2..-1]]; tarpow:=1;
 fi;
 return [-1,"auto",[src[-1]],1,tarfound,tarpow];
end proc:

EasyModsLister:=proc(iS,iL,dValue)
 local EasyMods, i, j, SDBt;
 EasyMods:=[]:
 for i to nops(iS) do
  SDBt:=SimpleDiffBuilder(iL[i],iS[i],dValue);
  if SDBt<>0 then
   SDBt[3]:=ExcessFormatSeq(SDBt[3]);
   for j to 100 while FinderNoErrors(SDBt[5],iL)<>0 do
    EasyMods:=[op(EasyMods),[op(SDBt[1..4]),ExcessFormatSeq(SDBt[5]),op(SDBt[6..-1])]]:
    if SDBt[6]<>1 then j:=10000; fi;
    SDBt[4]:=SDBt[4]*2;
    SDBt[5]:=[[0],op(SDBt[5])];
   od;
  fi;
 od:
 EasyMods;
end proc:

SimpleDiffBuilder2:=proc(srcEx,SS,dValue)
 local b,tar,bfound,tarfound,tarpow,ellone,excess,jay;
 if nops(remove(x->x=[],srcEx))<>2 or nops(srcEx[-2])<>1############## or SS[2]<>1
  then return 0; fi;
 jay:=srcEx[-2][-1];
 ellone:=nops(srcEx[-1]);
 excess:=add(srcEx[-1][i],i=1..nops(srcEx[-1]));
 if jay>=ellone then
  error cat(convert(srcEx,string)," is not an unstable element!");
 elif jay<2+dValue+ellone-excess then
  return 0;
 elif SS[1..2]<>["poly",1] then
  error cat(cat("strange that",convert(srcEx,string)),"should already have been involved");
 fi;
 tarfound:=[[jay-1-(dValue+ellone-excess),(dValue+ellone-excess)],srcEx[-1][2..-1]];
 return [-1,"auto",srcEx[-2..-1],1,tarfound,1];
end proc:

EasyModsLister2:=proc(iS,iL,dValue)
 local EasyMods, i, j, SDBt, SDBti, iLe;
 EasyMods:=[]:
 iLe:=map(ExcessFormatSeq,iL);
 for i to nops(iS) do
  SDBti:=SimpleDiffBuilder2(iLe[i],iS[i],dValue);
  if SDBti<>0 then
   SDBt:=SDBti;
   for j to 100 while FinderNoErrors(SDBt[5],iLe)<>0 do
    EasyMods:=[op(EasyMods),SDBt]:
    if SDBt[6]<>1 then j:=10000; fi;
    SDBt[4]:=SDBt[4]*2;
    SDBt[5]:=[[nops(SDBt[5][1])-1],op(SDBt[5])];
   od;
#   SDBt:=[SDBti[1],SDBti[2],[[0],op(SDBti[3])],SDBti[4],[[0],op(SDBti[5])],SDBti[6]];
#   for j to 100 while FinderNoErrors(SDBt[5],iLe)<>0 do
#    EasyMods:=[op(EasyMods),SDBt]:
#    if SDBt[6]<>1 then j:=10000; fi;
#    SDBt[3]:=[[0],op(SDBt[3])];
#    SDBt[5]:=[[0],op(SDBt[5])];
#   od;
#I'm not sure I believe this differential, given
#[352, "d9", [[0], [0], [4], [3, 0, 0, 0, 2]], 1, [[1, 0], [1, 2], [0, 0, 0, 2]], 1]
#Instead, I think it's "add a zero at front adds a zero at front", "add two zeros at front adds a 01 at front".
  fi;
 od:
 EasyMods;
end proc:

ModsTrimmer:=proc(Mods,EasyMods)
 local EM;
 EM:=map(x->x[-4..-1],map(x->op(x),[args[2..nargs]]));
 remove(x->0<>ListTools[Search](x[-4..-1],EM),Mods);
end proc:

ExcessFormatSingle:=y->`if`(y=[],[],
  [seq(y[i-1]-2*y[i],i=2..nops(y)),y[-1]]):
ExcessFormatSeq:=y->`if`(y=[[]] or y=[],y,
  [op(y[1..-2]),ExcessFormatSingle(y[-1])]):
ExcessFormatPR:=y->map(x->[x[1],ExcessFormatSeq(x[2])],y):
unExcessFormatSingle:=proc(y)
 local j,ans;
 ans:=y;
 for j from nops(y)-1 to 1 by -1 do
  ans[j]:=ans[j]+2*ans[j+1];
 od:
 return ans;
end proc:
unExcessFormatSeq:=y->`if`(y=[[]] or y=[],y,
  [op(y[1..-2]),unExcessFormatSingle(y[-1])]):
unExcessFormatPR:=y->map(x->[x[1],unExcessFormatSeq(x[2])],y):

ModsOrder:=proc(x,y,dValue)
 local sx,sy;
 sx:=x[-3]*tMINUSsAdjusted(unExcessFormatSeq(x[-4]),dValue);
 sy:=y[-3]*tMINUSsAdjusted(unExcessFormatSeq(y[-4]),dValue);
 if sx<sy then return true;
 elif sx>sy then return false;
 fi;
 return lexorder(convert(x[-4],string),convert(y[-4],string));
end proc:
ModsAreEssentiallyEqual:=proc(x,y)
 return evalb(x[-4..-1]=y[-4..-1])
end proc:
ModStem:=proc(M,dValue)
 return M[-3]*tMINUSsAdjusted(unExcessFormatSeq(M[-4]),dValue);
end proc:
DifferentialDebugger:=proc(mods1,mods2,list1nick:="list 1",list2nick:="list 2",maxStemYouCareAbout:=1000000)
##eg: DifferentialDebugger(ModsTrimmer(AllMods,EasyMods),EasyMods2,"Manual-Easy1","Easy2",600);
##    DifferentialDebugger(ModsTrimmer(AllMods,EasyMods,EasyMods2),[],"Manual-Easy12","null",600);
 local mods1t,mods2t,mods1minus2,mods2minus1,mods1minus2stems,mods2minus1stems,i;
 mods1t:=map(x->x[-4..-1],mods1);
 mods2t:=map(x->x[-4..-1],mods2);
 mods1t:=remove(x->ModStem(x,dValue)>maxStemYouCareAbout,mods1t);
 mods2t:=remove(x->ModStem(x,dValue)>maxStemYouCareAbout,mods2t);
 mods1minus2:=sort([op({op(mods1t)}minus{op(mods2t)})],(x,y)->ModsOrder(x,y,dValue));
 mods2minus1:=sort([op({op(mods2t)}minus{op(mods1t)})],(x,y)->ModsOrder(x,y,dValue));
 mods1minus2stems:=map(x->ModStem(x,dValue),mods1minus2);
 mods2minus1stems:=map(x->ModStem(x,dValue),mods2minus1);
 UserFeedback("In ",list1nick," but not in ",list2nick,", up to stem ",maxStemYouCareAbout,":");
 for i to nops(mods1minus2) do
  UserFeedback(list1nick,", stem ",mods1minus2stems[i],": ",mods1minus2[i]);
 od;
 UserFeedback("In ",list2nick," but not in ",list1nick,", up to stem ",maxStemYouCareAbout,":");
 for i to nops(mods2minus1) do
  UserFeedback(list2nick,", stem ",mods2minus1stems[i],": ",mods2minus1[i]);
 od;
 UserFeedback("That's all.");
end proc:#*#*#################### begin program ####################
dValue:=2: calcToDimension:=600:
applyEasyMods:=true:
applyEasyMods2:=true:
fileNm:=cat(cat(cat("C:\\maple_output\\S",dValue),"dim"),calcToDimension):
if FileTools[Exists](fileNm)=false then
 constructSandL(calcToDimension,dValue):
 #I bet the calculation of l1max in here is wrong... the 5/9 numbers
 #are a global bound on ratios, but once you know that t is some size in
 #a sequence, there's probably no way that it can fail to have t-s a certain size.
 #Eg doesn't applying any S just increase topological dimension? It's close to squaring!
 iS:=%[1]:iL:=%%[2]:
 save iL, iS, cat(fileNm);
else
 read fileNm:
 UserFeedback("iS and iL were read from ",fileNm,". They contain ",nops(iL)," elements each.");
 if nops(iS)<>nops(iL) then
  error "actually, they don't!";
 fi;
fi:#*#*############## automatic modifications ################
easyS:=iS:easyL:=iL:
EasyMods:=`if`(applyEasyMods,EasyModsLister(iS,iL,dValue),[]):
if applyEasyMods then
 UserFeedback("there are ",nops(EasyMods)," simple modifications")
fi;
for MM in EasyMods do
 easyS:=difl(op(MM),easyL,easyS,10000,"quiet"):
od:
EasyMods2:=`if`(applyEasyMods2,EasyModsLister2(easyS,easyL,dValue),[]):
if applyEasyMods2 then
 UserFeedback("there are ",nops(EasyMods2)," simple modifications of type 2")
fi;
for MM in EasyMods2 do
 easyS:=difl(op(MM),easyL,easyS,10000,"quiet"):
od:#*#*######### manual modifications, get results ###########
AllMods:=[
[1, "d5", [[0], [4], [3, 0, 0, 0, 2]], 1, [[0], [1, 2], [0, 0, 0, 2]], 1],
[2, "d5", [[0], [4], [2, 1, 0, 0, 2]], 1, [[0], [1, 2], [1, 0, 0, 2]], 1],
[3, "d5", [[0], [4], [1, 2, 0, 0, 2]], 1, [[0], [1, 2], [2, 0, 0, 2]], 1],
[4, "d5", [[0], [4], [2, 0, 1, 0, 2]], 1, [[0], [1, 2], [0, 1, 0, 2]], 1],
[5, "d5", [[0], [4], [0, 3, 0, 0, 2]], 1, [[0], [1, 2], [3, 0, 0, 2]], 1],
[6, "d5", [[0], [4], [1, 1, 1, 0, 2]], 1, [[0], [1, 2], [1, 1, 0, 2]], 1],
[7, "d5", [[0], [4], [0, 2, 1, 0, 2]], 1, [[0], [1, 2], [2, 1, 0, 2]], 1],
[8, "d5", [[0], [4], [1, 0, 2, 0, 2]], 1, [[0], [1, 2], [0, 2, 0, 2]], 1],
[9, "d5", [[0], [4], [0, 1, 2, 0, 2]], 1, [[0], [1, 2], [1, 2, 0, 2]], 1],
[10, "d5", [[0], [4], [2, 0, 0, 1, 2]], 1, [[0], [1, 2], [0, 0, 1, 2]], 1],
[11, "d5", [[0], [4], [1, 1, 0, 1, 2]], 1, [[0], [1, 2], [1, 0, 1, 2]], 1],
[12, "d5", [[0], [4], [0, 2, 0, 1, 2]], 1, [[0], [1, 2], [2, 0, 1, 2]], 1],
[13, "d5", [[0], [4], [1, 0, 1, 1, 2]], 1, [[0], [1, 2], [0, 1, 1, 2]], 1],
[14, "d5", [[0], [4], [0, 1, 1, 1, 2]], 1, [[0], [1, 2], [1, 1, 1, 2]], 1],
[15, "d9", [[0], [5], [3, 0, 0, 0, 0, 2]], 1, [[0], [1, 3], [0, 0, 0, 0, 2]], 1],
[16, "d5", [[0], [5], [4, 0, 0, 0, 0, 2]], 1, [[0], [2, 2], [0, 0, 0, 0, 2]], 1],
[17, "d5", [[0], [4], [4, 0, 0, 0, 0, 2]], 1, [[0], [1, 2], [0, 0, 0, 0, 2]], 1],
[18, "d5", [[1, 4], [4, 0, 0, 0, 0, 2]], 1, [[1, 1, 2], [0, 0, 0, 0, 2]], 1],
[19, "d9", [[0], [5], [2, 1, 0, 0, 0, 2]], 1, [[0], [1, 3], [1, 0, 0, 0, 2]], 1],
[20, "d5", [[0], [5], [3, 1, 0, 0, 0, 2]], 1, [[0], [2, 2], [1, 0, 0, 0, 2]], 1],
[21, "d5", [[0], [4], [3, 1, 0, 0, 0, 2]], 1, [[0], [1, 2], [1, 0, 0, 0, 2]], 1],
[22, "d5", [[1, 4], [3, 1, 0, 0, 0, 2]], 1, [[1, 1, 2], [1, 0, 0, 0, 2]], 1],
[23, "d9", [[0], [4], [3, 0, 0, 0, 2]], 2, [[0], [0], [1, 2], [0, 0, 0, 2]], 1],
[24, "d9", [[0], [5], [1, 2, 0, 0, 0, 2]], 1, [[0], [1, 3], [2, 0, 0, 0, 2]], 1],
[25, "d9", [[0], [0], [4], [3, 0, 0, 0, 2]], 1, [[1, 0], [1, 2], [0, 0, 0, 2]], 1],
[26, "d5", [[0], [5], [2, 2, 0, 0, 0, 2]], 1, [[0], [2, 2], [2, 0, 0, 0, 2]], 1],
[27, "d5", [[0], [4], [2, 2, 0, 0, 0, 2]], 1, [[0], [1, 2], [2, 0, 0, 0, 2]], 1],
[28, "d5", [[1, 4], [2, 2, 0, 0, 0, 2]], 1, [[1, 1, 2], [2, 0, 0, 0, 2]], 1],
[29, "d9", [[0], [5], [0, 3, 0, 0, 0, 2]], 1, [[0], [1, 3], [3, 0, 0, 0, 2]], 1],
[30, "d9", [[0], [5], [2, 0, 1, 0, 0, 2]], 1, [[0], [1, 3], [0, 1, 0, 0, 2]], 1],
[31, "d5", [[0], [5], [3, 0, 1, 0, 0, 2]], 1, [[0], [2, 2], [0, 1, 0, 0, 2]], 1],
[32, "d5", [[0], [5], [1, 3, 0, 0, 0, 2]], 1, [[0], [2, 2], [3, 0, 0, 0, 2]], 1],
[33, "d5", [[0], [4], [1, 3, 0, 0, 0, 2]], 1, [[0], [1, 2], [3, 0, 0, 0, 2]], 1],
[34, "d5", [[0], [4], [3, 0, 1, 0, 0, 2]], 1, [[0], [1, 2], [0, 1, 0, 0, 2]], 1],
[35, "d5", [[1, 4], [1, 3, 0, 0, 0, 2]], 1, [[1, 1, 2], [3, 0, 0, 0, 2]], 1],
[36, "d5", [[1, 4], [3, 0, 1, 0, 0, 2]], 1, [[1, 1, 2], [0, 1, 0, 0, 2]], 1],
[37, "d9", [[0], [4], [2, 1, 0, 0, 2]], 2, [[0], [0], [1, 2], [1, 0, 0, 2]], 1],
[38, "d9", [[0], [5], [1, 1, 1, 0, 0, 2]], 1, [[0], [1, 3], [1, 1, 0, 0, 2]], 1],
[39, "d9", [[0], [0], [4], [2, 1, 0, 0, 2]], 1, [[1, 0], [1, 2], [1, 0, 0, 2]], 1],
[40, "d5", [[0], [5], [0, 4, 0, 0, 0, 2]], 1, [[0], [2, 2], [4, 0, 0, 0, 2]], 1],
[41, "d5", [[0], [5], [2, 1, 1, 0, 0, 2]], 1, [[0], [2, 2], [1, 1, 0, 0, 2]], 1],
[42, "d5", [[0], [4], [0, 4, 0, 0, 0, 2]], 1, [[0], [1, 2], [4, 0, 0, 0, 2]], 1],
[43, "d5", [[0], [4], [2, 1, 1, 0, 0, 2]], 1, [[0], [1, 2], [1, 1, 0, 0, 2]], 1],
[44, "d5", [[1, 4], [0, 4, 0, 0, 0, 2]], 1, [[1, 1, 2], [4, 0, 0, 0, 2]], 1],
[45, "d5", [[1, 4], [2, 1, 1, 0, 0, 2]], 1, [[1, 1, 2], [1, 1, 0, 0, 2]], 1],
[46, "d9", [[0], [5], [0, 2, 1, 0, 0, 2]], 1, [[0], [1, 3], [2, 1, 0, 0, 2]], 1],
[47, "d5", [[0], [5], [1, 2, 1, 0, 0, 2]], 1, [[0], [2, 2], [2, 1, 0, 0, 2]], 1],
[48, "d5", [[0], [4], [1, 2, 1, 0, 0, 2]], 1, [[0], [1, 2], [2, 1, 0, 0, 2]], 1],
[49, "d5", [[1, 4], [1, 2, 1, 0, 0, 2]], 1, [[1, 1, 2], [2, 1, 0, 0, 2]], 1],
[50, "d9", [[0], [4], [1, 2, 0, 0, 2]], 2, [[0], [0], [1, 2], [2, 0, 0, 2]], 1],
[51, "d9", [[0], [5], [1, 0, 2, 0, 0, 2]], 1, [[0], [1, 3], [0, 2, 0, 0, 2]], 1],
[52, "d9", [[0], [0], [4], [1, 2, 0, 0, 2]], 1, [[1, 0], [1, 2], [2, 0, 0, 2]], 1],
[53, "d5", [[0], [5], [0, 3, 1, 0, 0, 2]], 1, [[0], [2, 2], [3, 1, 0, 0, 2]], 1],
[54, "d5", [[0], [5], [2, 0, 2, 0, 0, 2]], 1, [[0], [2, 2], [0, 2, 0, 0, 2]], 1],
[55, "d5", [[0], [4], [0, 3, 1, 0, 0, 2]], 1, [[0], [1, 2], [3, 1, 0, 0, 2]], 1],
[56, "d5", [[0], [4], [2, 0, 2, 0, 0, 2]], 1, [[0], [1, 2], [0, 2, 0, 0, 2]], 1],
[57, "d5", [[1, 4], [0, 3, 1, 0, 0, 2]], 1, [[1, 1, 2], [3, 1, 0, 0, 2]], 1],
[58, "d5", [[1, 4], [2, 0, 2, 0, 0, 2]], 1, [[1, 1, 2], [0, 2, 0, 0, 2]], 1],
[59, "d9", [[0], [5], [0, 1, 2, 0, 0, 2]], 1, [[0], [1, 3], [1, 2, 0, 0, 2]], 1],
[60, "d9", [[0], [5], [2, 0, 0, 1, 0, 2]], 1, [[0], [1, 3], [0, 0, 1, 0, 2]], 1],
[61, "d5", [[0], [5], [1, 1, 2, 0, 0, 2]], 1, [[0], [2, 2], [1, 2, 0, 0, 2]], 1],
[62, "d5", [[0], [5], [3, 0, 0, 1, 0, 2]], 1, [[0], [2, 2], [0, 0, 1, 0, 2]], 1],
[63, "d5", [[0], [4], [1, 1, 2, 0, 0, 2]], 1, [[0], [1, 2], [1, 2, 0, 0, 2]], 1],
[64, "d5", [[0], [4], [3, 0, 0, 1, 0, 2]], 1, [[0], [1, 2], [0, 0, 1, 0, 2]], 1],
[65, "d5", [[1, 4], [1, 1, 2, 0, 0, 2]], 1, [[1, 1, 2], [1, 2, 0, 0, 2]], 1],
[66, "d5", [[1, 4], [3, 0, 0, 1, 0, 2]], 1, [[1, 1, 2], [0, 0, 1, 0, 2]], 1],
[67, "d9", [[0], [4], [0, 3, 0, 0, 2]], 2, [[0], [0], [1, 2], [3, 0, 0, 2]], 1],
[68, "d9", [[0], [4], [2, 0, 1, 0, 2]], 2, [[0], [0], [1, 2], [0, 1, 0, 2]], 1],
[69, "d9", [[0], [5], [1, 1, 0, 1, 0, 2]], 1, [[0], [1, 3], [1, 0, 1, 0, 2]], 1],
[70, "d9", [[0], [0], [4], [0, 3, 0, 0, 2]], 1, [[1, 0], [1, 2], [3, 0, 0, 2]], 1],
[71, "d9", [[0], [0], [4], [2, 0, 1, 0, 2]], 1, [[1, 0], [1, 2], [0, 1, 0, 2]], 1],
[72, "d5", [[0], [5], [0, 2, 2, 0, 0, 2]], 1, [[0], [2, 2], [2, 2, 0, 0, 2]], 1],
[73, "d5", [[0], [5], [2, 1, 0, 1, 0, 2]], 1, [[0], [2, 2], [1, 0, 1, 0, 2]], 1],
[74, "d5", [[0], [4], [0, 2, 2, 0, 0, 2]], 1, [[0], [1, 2], [2, 2, 0, 0, 2]], 1],
[75, "d5", [[0], [4], [2, 1, 0, 1, 0, 2]], 1, [[0], [1, 2], [1, 0, 1, 0, 2]], 1],
[76, "d5", [[1, 4], [0, 2, 2, 0, 0, 2]], 1, [[1, 1, 2], [2, 2, 0, 0, 2]], 1],
[77, "d5", [[1, 4], [2, 1, 0, 1, 0, 2]], 1, [[1, 1, 2], [1, 0, 1, 0, 2]], 1],
[78, "d9", [[0], [5], [0, 0, 3, 0, 0, 2]], 1, [[0], [1, 3], [0, 3, 0, 0, 2]], 1],
[79, "d9", [[0], [5], [0, 2, 0, 1, 0, 2]], 1, [[0], [1, 3], [2, 0, 1, 0, 2]], 1]
]:
Mods:=ModsTrimmer(AllMods,EasyMods,EasyMods2):
S:=easyS: L:=easyL: MctrMax:=10000: MctrMin:=Mods[-1][1]:
for MM in Mods while MM[1]<=MctrMax do
 if MM[1]>=MctrMin then 
  OutputMatrix(S,L,BDimFind(S,L)+2,"FileSuffixHere","quiet"):
  S:=difl(op(MM),L,S,MctrMax," leads to..."): 
 else
  S:=difl(op(MM),L,S,MctrMax,"quiet"):
 fi:
od:
OM:=OutputMatrix(S,L,BDimFind(S,L)+2,"FileSuffixHere","3colLoud"):
if BDimFind(S,L)+2>=calcToDimension then error "too close to top dimension" fi:#*#*############### extract a differential ################
SrcTarA:=[1,2]:
UserFeedback(time(),"s: proposed a differential:");
diffExtractor(op(SrcTarA),OM,AllMods);#*#*############## extract two differentials ##############
SrcTarA:=[1,4]: SrcTarB:=[2,3]:
UserFeedback(time(),"s: proposed two differentials:");
print(((diffExtractor(op(SrcTarA),OM,AllMods))),(diffExtractor(op(SrcTarB),OM,[[AllMods[-1][1]+1]])));#*#*############## extract three differentials ############
SrcTarA:=[1,6]: SrcTarB:=[3,5]: SrcTarC:=[2,7]:
UserFeedback(time(),"s: proposed three differentials:");
print(((diffExtractor(op(SrcTarA),OM,AllMods))),
(diffExtractor(op(SrcTarB),OM,[[AllMods[-1][1]+1]])),
(diffExtractor(op(SrcTarC),OM,[[AllMods[-1][1]+2]])));#*#*########## list all manual differentials ##############
DifferentialDebugger(Mods,[],"manual","[]");#*#*##### list certain interesting differentials ##########
tester:=[]:
for j in Mods do
 if nops(j[3])=2 and nops(j[3][1])=1 then
  #tester:=[op(tester),[(j," has a from ",
     #nops(j[3][2])-(add(j[3][2][k],k=1..nops(j[3][2]))- (dValue+2) )," to ",nops(j[3][2])-1)]];
  newnums:=[j[3][-2][1]-1-(dValue+nops(j[3][-1])-add(j[3][-1][k],k=1..nops(j[3][-1]))),
                          (dValue+nops(j[3][-1])-add(j[3][-1][k],k=1..nops(j[3][-1])))];
  tester:=[op(tester),[(j," has newnumbers ",newnums[1]," and ",newnums[2],"... ",evalb(j[4]<>1 or j[5]=[newnums,j[3][-1][2..-1]]))]];
 fi;
od:
tester:=sort(tester,(x,y)->lexorder(convert(x[1][3][2],string),convert(y[1][3][2],string))):
for j from 1 to nops(tester) do
 UserFeedback(op(tester[j]));
 if j=nops(tester) or tester[j][1][3][-1]<>tester[j+1][1][3][-1] then
  UserFeedback("       ",(EasyMods[ListTools[Search](tester[j][1][3][-1],map(x->x[3][-1],EasyMods))]),"\n");
 fi;
od:#*#*##### list certain interesting differentials ##########
tester:=[]:
for j in Mods do
 if nops(j[3])=2 then#and nops(j[3][1])=1 then
  #tester:=[op(tester),[(j," has a from ",
     #nops(j[3][2])-(add(j[3][2][k],k=1..nops(j[3][2]))- (dValue+2) )," to ",nops(j[3][2])-1)]];
  newnums:=[j[3][-2][-1]-1-(dValue+nops(j[3][-1])-add(j[3][-1][k],k=1..nops(j[3][-1]))),
                          (dValue+nops(j[3][-1])-add(j[3][-1][k],k=1..nops(j[3][-1])))];
 #########1st number=1+j+excess-(d+2+ell)=j-1-(d+l-e)
 #########2nd number=(d+l-e)
  tester:=[op(tester),[(j," has newnumbers ",newnums[1]," and ",newnums[2],"... ",evalb(j[4]<>1 or j[5]=[newnums,j[3][-1][2..-1]]))]];
 fi;
od:
tester:=sort(tester,(x,y)->lexorder(convert(x[1][3][2],string),convert(y[1][3][2],string))):
for j from 1 to nops(tester) do
 UserFeedback(op(tester[j]));
 if j=nops(tester) or tester[j][1][3][-1]<>tester[j+1][1][3][-1] then
  UserFeedback("       ",(EasyMods[ListTools[Search](tester[j][1][3][-1],map(x->x[3][-1],EasyMods))]),"\n");
 fi;
od:





















1manual, stem 271: [[[0], [4], [3, 0, 0, 0, 2]], 1, [[0], [1, 2], [0, 0, 0, 2]], 1]
          [1, "d5", [[0], [4], [3, 0, 0, 0, 2]], 1, [[0], [1, 2], [0, 0, 0, 2]], 1],

2manual, stem 279: [[[0], [4], [2, 1, 0, 0, 2]], 1, [[0], [1, 2], [1, 0, 0, 2]], 1]
          [2, "d5", [[0], [4], [2, 1, 0, 0, 2]], 1, [[0], [1, 2], [1, 0, 0, 2]], 1],

3manual, stem 287: [[[0], [4], [1, 2, 0, 0, 2]], 1, [[0], [1, 2], [2, 0, 0, 2]], 1]
          [3, "d5", [[0], [4], [1, 2, 0, 0, 2]], 1, [[0], [1, 2], [2, 0, 0, 2]], 1],

4manual, stem 295: [[[0], [4], [0, 3, 0, 0, 2]], 1, [[0], [1, 2], [3, 0, 0, 2]], 1]
          [4, "d5", [[0], [4], [2, 0, 1, 0, 2]], 1, [[0], [1, 2], [0, 1, 0, 2]], 1],

5manual, stem 295: [[[0], [4], [2, 0, 1, 0, 2]], 1, [[0], [1, 2], [0, 1, 0, 2]], 1]
          [5, "d5", [[0], [4], [0, 3, 0, 0, 2]], 1, [[0], [1, 2], [3, 0, 0, 2]], 1],

6manual, stem 303: [[[0], [4], [1, 1, 1, 0, 2]], 1, [[0], [1, 2], [1, 1, 0, 2]], 1]
          [6, "d5", [[0], [4], [1, 1, 1, 0, 2]], 1, [[0], [1, 2], [1, 1, 0, 2]], 1],

7manual, stem 311: [[[0], [4], [0, 2, 1, 0, 2]], 1, [[0], [1, 2], [2, 1, 0, 2]], 1]
          [7, "d5", [[0], [4], [0, 2, 1, 0, 2]], 1, [[0], [1, 2], [2, 1, 0, 2]], 1],

8manual, stem 319: [[[0], [4], [1, 0, 2, 0, 2]], 1, [[0], [1, 2], [0, 2, 0, 2]], 1]
          [8, "d5", [[0], [4], [1, 0, 2, 0, 2]], 1, [[0], [1, 2], [0, 2, 0, 2]], 1],

9manual, stem 327: [[[0], [4], [0, 1, 2, 0, 2]], 1, [[0], [1, 2], [1, 2, 0, 2]], 1]
          [9, "d5", [[0], [4], [0, 1, 2, 0, 2]], 1, [[0], [1, 2], [1, 2, 0, 2]], 1],

0manual, stem 327: [[[0], [4], [2, 0, 0, 1, 2]], 1, [[0], [1, 2], [0, 0, 1, 2]], 1]
         [10, "d5", [[0], [4], [2, 0, 0, 1, 2]], 1, [[0], [1, 2], [0, 0, 1, 2]], 1],

1manual, stem 335: [[[0], [4], [1, 1, 0, 1, 2]], 1, [[0], [1, 2], [1, 0, 1, 2]], 1]
         [11, "d5", [[0], [4], [1, 1, 0, 1, 2]], 1, [[0], [1, 2], [1, 0, 1, 2]], 1],

2manual, stem 343: [[[0], [4], [0, 2, 0, 1, 2]], 1, [[0], [1, 2], [2, 0, 1, 2]], 1]
         [12, "d5", [[0], [4], [0, 2, 0, 1, 2]], 1, [[0], [1, 2], [2, 0, 1, 2]], 1],

3manual, stem 351: [[[0], [4], [1, 0, 1, 1, 2]], 1, [[0], [1, 2], [0, 1, 1, 2]], 1]
         [13, "d5", [[0], [4], [1, 0, 1, 1, 2]], 1, [[0], [1, 2], [0, 1, 1, 2]], 1],

4manual, stem 359: [[[0], [4], [0, 1, 1, 1, 2]], 1, [[0], [1, 2], [1, 1, 1, 2]], 1]
         [14, "d5", [[0], [4], [0, 1, 1, 1, 2]], 1, [[0], [1, 2], [1, 1, 1, 2]], 1],

5manual, stem 527: [[[0], [5], [3, 0, 0, 0, 0, 2]], 1, [[0], [1, 3], [0, 0, 0, 0, 2]], 1]
         [15, "d9", [[0], [5], [3, 0, 0, 0, 0, 2]], 1, [[0], [1, 3], [0, 0, 0, 0, 2]], 1],

6manual, stem 531: [[[0], [5], [4, 0, 0, 0, 0, 2]], 1, [[0], [2, 2], [0, 0, 0, 0, 2]], 1]
         [16, "d5", [[0], [5], [4, 0, 0, 0, 0, 2]], 1, [[0], [2, 2], [0, 0, 0, 0, 2]], 1],

7manual, stem 533: [[[0], [4], [4, 0, 0, 0, 0, 2]], 1, [[0], [1, 2], [0, 0, 0, 0, 2]], 1]
         [17, "d5", [[0], [4], [4, 0, 0, 0, 0, 2]], 1, [[0], [1, 2], [0, 0, 0, 0, 2]], 1],

8manual, stem 534: [[[1, 4], [4, 0, 0, 0, 0, 2]], 1, [[1, 1, 2], [0, 0, 0, 0, 2]], 1]
         [18, "d5", [[1, 4], [4, 0, 0, 0, 0, 2]], 1, [[1, 1, 2], [0, 0, 0, 0, 2]], 1],

9manual, stem 535: [[[0], [5], [2, 1, 0, 0, 0, 2]], 1, [[0], [1, 3], [1, 0, 0, 0, 2]], 1]
         [19, "d9", [[0], [5], [2, 1, 0, 0, 0, 2]], 1, [[0], [1, 3], [1, 0, 0, 0, 2]], 1],

0manual, stem 539: [[[0], [5], [3, 1, 0, 0, 0, 2]], 1, [[0], [2, 2], [1, 0, 0, 0, 2]], 1]
         [20, "d5", [[0], [5], [3, 1, 0, 0, 0, 2]], 1, [[0], [2, 2], [1, 0, 0, 0, 2]], 1],

1manual, stem 541: [[[0], [4], [3, 1, 0, 0, 0, 2]], 1, [[0], [1, 2], [1, 0, 0, 0, 2]], 1]
         [21, "d5", [[0], [4], [3, 1, 0, 0, 0, 2]], 1, [[0], [1, 2], [1, 0, 0, 0, 2]], 1],






[352, "d9", [[0], [0], [4], [3, 0, 0, 0, 2]], 1, [[1, 0], [1, 2], [0, 0, 0, 2]], 1]