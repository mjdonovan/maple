writeline(default,"reading function definitions"):
AdemIndexPairs:=proc(i,j,algtype)
 local ans,s;
 if algtype="u" then
  if i>2*j then
   ans:=[];
   for s from 0 to floor(.5*(i-2*j)-1) do
    if binomial(i-2*j-2-s,s) mod 2=1 then
     ans:=[op(ans),[2*j+1+s,i-j-1-s]];
    fi;
   od;
  else
   ans:=[[i,j]];
  fi;
 elif algtype="Sq1+" then
  if i<=2*j then
   ans:=[];
   for s from 0 to floor(.5*(i-1)) do
    if binomial(j-s-1,i-2*s-1) mod 2=1 then
     ans:=[op(ans),[i+j-s,s]];
    fi;
   od;
  else
   ans:=[[i,j]];
  fi;
 elif algtype="P" then
  if i>=2*j then
   ans:=[];
   for s from i-j+1 to i+j-2 do
    if binomial(2*s-i-1,s-j) mod 2=1 then
     ans:=[op(ans),[i+j-s,s]];
    fi;
   od;
  else
   ans:=[[i,j]];
  fi;
 elif algtype="d" or algtype="dNS" then
  if i<2*j then
   ans:=[];
   for s from ceil((i+1)/2) to floor((i+j)/3) do
    if binomial(j-i+s-1,j-s) mod 2=1 then
     ans:=[op(ans),[i+j-s,s]];
    fi;
   od;
  else
   ans:=[[i,j]];
  fi;
 else
  error "unknown algtype"
 end if;
 ans;
end proc:

MakesSense:=proc(L,algtype)
 local i;
 if algtype="u" or algtype="Sq1+" then
  for i from 1 to nops(L) do
   if type(L[i],nonnegint)=false then
    error "bad entry";
   fi; 
  od;
 elif algtype="P" or algtype="d" or algtype="dNS" then
  for i from 1 to nops(L) do
   if type(L[i]-1,posint)=false then
    error "bad entry";
   fi; 
  od;
 else
  error "unknown algtype"
 end if;
end proc:

IsAdmissible:=proc(L,algtype)
 local i, ans;
 ans:=true;
 if algtype="u" then
  for i from 1 to nops(L)-1 while ans=true do
   if L[i]>2*L[i+1] then
    ans:=i;
   fi;
  end do;  
 elif algtype="Sq1+" then
  for i from 1 to nops(L)-1 while ans=true do
   if L[i]<=2*L[i+1] then
    ans:=i;
   fi;
  end do;  
 elif algtype="P" then
  for i from 1 to nops(L)-1 while ans=true do
   if L[i]>=2*L[i+1] then
    ans:=i;
   fi;
  end do;  
 elif algtype="d" or algtype="dNS" then
  for i from 1 to nops(L)-1 while ans=true do
   if L[i]<2*L[i+1] then
    ans:=i;
   fi;
  end do;  
 else
  error "unknown algtype"
 end if;
 ans;
end proc:

AdemAtLocation:=proc(L,loc,algtype)
 map(AR->[op(L[1..loc-1]),op(AR),op(L[loc+2..nops(L)])],
    AdemIndexPairs(L[loc],L[loc+1],algtype));
end proc:

ListModTwo:=proc(L)
 local ans,i,T;
 T:=ListTools[MakeUnique](L); ans:=[];
 for i from 1 to nops(T) do
  if (numboccur(L,{T[i]}) mod 2)=1 then
   ans:=[op(ans),T[i]];
  fi;
 od;
 ans;
end proc:

AddListsModTwo:=proc(N1:=[],N2:=[],N3:=[],N4:=[],N5:=[],N6:=[],N7:=[])
 ListModTwo([op(N1),op(N2),op(N3),op(N4),op(N5),op(N6),op(N7)])
end proc:

QueueAdem:=proc(seqn,algtype)
 local ADMISlist,q,i,ent,ADM,j,PostReln;
 if nargs>2 then print("input"=seqn);fi;
 ADMISlist:=[]:
 q := queue:-new(seqn):
 for i to 10000 while queue:-length(q)>0 do
  ent:=queue:-dequeue(q);
  ADM:=IsAdmissible(ent,algtype);
  if ADM=true then
   ADMISlist:=[op(ADMISlist),ent];
  else
   PostReln:=AdemAtLocation(ent,ADM,algtype);
   if nargs>2 then print(ent,"inadmissible at",ent[ADM..ADM+1],"giving",nops
(PostReln), "terms");fi;
   for j to nops(PostReln) do
    queue:-enqueue(q,PostReln[j]);
    if nargs>2 then print(PostReln[j]," enqueued");fi;
   od;
  fi;
 end do:
 if nargs>2 then print("if",queue:-length(q)=0,"then have emptied queue and result 
follows");fi;
 ListModTwo(ADMISlist);
end proc:

MinDegree:=proc(L,algtype)
 local ans,shift,i,storeddim;
 if algtype="u" or algtype="Sq1+" or algtype="dNS" then
  shift:=0;
 elif algtype="P" or algtype="d" then
  shift:=1;
 else
  error "unknown algtype"
 end if;
 if nops(L)=0 then
  ans:=-1;
 else
  ans:=L[nops(L)];
  storeddim:=0;
  for i by -1 from nops(L)-1 to 1 do
   storeddim:=storeddim+L[i+1]+shift;
   ans:=max(ans,L[i]-storeddim);
  od;
 fi;
 ans;
end proc:

InternalDegree:=proc(L,algtype)
 local ans;
 if algtype="u" or algtype="Sq1+" or algtype="dNS" or algtype="sum" then
  ans:=sum(L[kakaka],kakaka=1..nops(L));
 elif algtype="P" or algtype="d" then
  ans:=sum(L[kakaka]+1,kakaka=1..nops(L));
 else
  error "unknown algtype"
 end if;
 ans;
end proc:

AllSequences:=proc(s,l,algtype)
 local m;
 if algtype="u" or algtype="Sq1+"  then
  m:=0;
 elif algtype="P" or algtype="d" or algtype="dNS" then
  m:=2;
 else
  error "unknown algtype"
 end if;
 sort(convert(map(xx->map(yy->yy+(m-1),xx),combinat[composition](s-l*(m-1),l)),list));
end proc:

AllSequencesReinvented:=proc(SuM,LengtH,algtype)
 local i,minclass,listo,temp;
 if algtype="u" or algtype="Sq1+"  then
  minclass:=0;
 elif algtype="P" or algtype="d" or algtype="dNS" then
  minclass:=2;
 else
  error "unknown algtype"
 end if;
 if LengtH=1 then
  listo:=[[SuM]];
 else
  listo:=[];
  for i from minclass to SuM-minclass*(LengtH-1) do
   temp:=AllSequencesReinvented(SuM-i,LengtH-1,algtype);
   listo:=[op(listo),op(map(AR->[i,op(AR)],temp))];
  od;
 fi;
 sort(listo);
end proc:

AllAdmissibleSequences:=proc(SuM,LengtH,algtype,prevEntry:=-1)
 local i,minclass,listo,temp;
 if algtype="u" or algtype="Sq1+"  then
  minclass:=0;
 elif algtype="P" or algtype="d" or algtype="dNS" then
  minclass:=2;
 else
  error "unknown algtype"
 end if;
 if LengtH=1 then
  if prevEntry=-1 or IsAdmissible([prevEntry,SuM],algtype)=true then
   listo:=[[SuM]];
  else
   listo:=[];
  fi;
 else
  listo:=[];
  for i from minclass to SuM-minclass*(LengtH-1) do
   if prevEntry=-1 or IsAdmissible([prevEntry,i],algtype)=true then
    temp:=AllAdmissibleSequences(SuM-i,LengtH-1,algtype,i);
    listo:=[op(listo),op(map(AR->[i,op(AR)],temp))];
   fi;
  od;
 fi;
 sort(listo);
end proc:

BarCycle:=proc(II,uOrP)
 local possibleJ,i,j,k,l,ANS,DorSq;
 if uOrP="u" then
  DorSq:="Sq1+";
 elif uOrP="P" then
  DorSq:="d";
 else
  error "need algtype P or u to do Koszul complex"
 end if;
 if IsAdmissible(II,DorSq)<>true then
  error "need Koszul-dual-admissible input"
 fi;
 ANS:=[];
 possibleJ:=AllSequences(InternalDegree(II,"sum"),nops(II),uOrP);
 for i to nops(possibleJ) do
  if (numboccur(II,QueueAdem(possibleJ[i],DorSq)) mod 2)=1 then
   ANS:=[op(ANS),possibleJ[i]];
  fi;
 od;
 sort(map(x->[map(y->[y],x),[]],ANS));
end proc:

BarDifferentialOnMonomial:=proc(b,uOrP)
 local i, ans, compactI, compactF, AdjProduct;
 if nops(b)<>2 or IsAdmissible(b[2],uOrP)<>true then error "b is bad" fi;
 for i from 1 to nops(b[1]) do
  if IsAdmissible(b[1][i],uOrP)<>true then error "b is bad" fi;
 od;
 ans:=[];
 compactI:=[op(b[1]),b[2]];
 for i from 1 to nops(b[1]) do
  AdjProduct:=QueueAdem([op(compactI[i]),op(compactI[i+1])],uOrP);
  compactF:= map(AR->[op(compactI[1..i-1]),(AR),op(compactI[i+2..nops(compactI)])],
    AdjProduct);
  compactF:=map(x->[x[1..nops(x)-1],x[nops(x)]],compactF);
  ans:=[op(ans),op(compactF)];
 od;
 ans;
end proc:

BarDifferential:=proc(B,uOrP)
 sort(ListModTwo(map(x->op(BarDifferentialOnMonomial(x,uOrP)),B)),MprecN);
end proc:

MprecN:=proc(M,N)
 local m,n,ans,i;
 m:=ListTools[FlattenOnce](M[1]);
 n:=ListTools[FlattenOnce](N[1]);
 if nops(m)>nops(n) then
  ans:=true;
 elif nops(m)<nops(n) then
  ans:=false;
 elif m=n then
  ans:=true;
 else
  ans:=5;
  for i from 1 to nops(m) while ans=5 do
   if   m[i]>n[i] then ans:=true
   elif m[i]<n[i] then ans:=false
   fi;
  od;
 fi;
 ans;
end proc:

LengthMinusHomDeg:=proc(M)
 nops(ListTools[FlattenOnce](M[1]))-nops(M[1]);
end proc:

PhiHomotopy:=proc(B,uOrP)
 local Bs,ms,num,i,j,ans,b,stillsingle,b1is,newb1,goforit;
 ans:=[];
 Bs:=sort(B,MprecN);
 ms:=map(x->ListTools[FlattenOnce](x[1]),Bs);
 if nops(B)=0 or nops(ms[1])=nops(Bs[1][1]) then
  print("done, dummy!");
  ans:=[];
 else
  num:=numboccur(ms,{ms[1]});
  for i from 1 to num do
   b:=Bs[i];
   stillsingle:=true;
   b1is:=[];
   for j from 1 to nops(b[1]) while stillsingle=true do
    b1is:=[op(b1is),[b[1][j][1]]];
    if nops(b[1][j])>1 then stillsingle:=false; fi;
   od;
   if uOrP="P" and IsAdmissible(ListTools[FlattenOnce](b1is),"d")=true then goforit:=true
   elif uOrP="u" and IsAdmissible(ListTools[FlattenOnce](b1is),"Sq1+")=true then goforit:=true
   else goforit:=false; fi;
   if goforit=true then
    newb1:=[op(b1is),b[1][nops(b1is)][2..nops(b[1][nops(b1is)])],
      op(b[1][nops(b1is)+1..nops(b[1])])];
    ans:=[op(ans),[newb1,b[2]]];
   fi;
  od;
 fi;
 ans;
end proc:

dPhi:=proc(B,uOrP)
 sort(BarDifferential(PhiHomotopy(B,uOrP),uOrP),MprecN);
end proc:

ADDdPhi:=proc(B,uOrP)
 sort(AddListsModTwo(B,BarDifferential(PhiHomotopy(B,uOrP),uOrP)),MprecN);
end proc:

RestrictionOfMuI:=proc(II,cDim)
 local i,ans,temp,topUdim,uII;
 if IsAdmissible(II,"Sq1+")<>true then error "not u-admissible" fi;
 if MinDegree(II,"u")>=cDim then error "not only nontop u" fi;
 if cDim<0 then error "negative dimensional class? really?" fi;
 ans:=[];
 topUdim:=cDim+InternalDegree(II,"u");
 uII:=BarCycle(II,"u");
 for i to nops(uII) do
  temp:=AdemIndexPairs(topUdim,uII[i][1][1][1],"u");
  temp:=map(a->[[a,op(uII[i][1][2..nops(uII[i][1])])],uII[i][2]],temp);
  ans:=[op(ans),op(temp)];
 od;
 sort(ListModTwo(ans),MprecN);
end proc:

RepeatedHomotopy:=proc(B,maxTries,uOrP)
 local i,T;
 T:=sort(B,MprecN);
 for i to maxTries while LengthMinusHomDeg(T[1])>0 do
  T:=ADDdPhi(T,uOrP);
 od;
 #if LengthMinusHomDeg(T[1])=0 then print(DONE); fi;
 T;
end proc:

MprecNalt:=proc(M,N)
 local ans,i;
 if nops(M[2])<nops(N[2]) then
  ans:=true;
 elif nops(M[2])>nops(N[2]) then
  ans:=false;
 elif M[2]=N[2] then
  ans:=MprecN(M,N)
 else
  ans:=5;
  for i from nops(M[2]) to 1 by -1 while ans=5 do
   if   M[2][i]<N[2][i] then ans:=true
   elif M[2][i]>N[2][i] then ans:=false
   fi;
  od;
 fi;
 ans;
end proc:

SqCompsMLi:=proc(M,L,i1min)
  local shifter,i;
  shifter:=[i1min-1];
  for i to L-1 do shifter:=[0,op(shifter)];od;
  map(xx->xx+shifter,combinat[composition](M-(i1min-1), L));
end proc:
SqCompsMi:=proc(M,i1min)
  local ans,L;
  ans:=[];
  for L from 1 to M-i1min+1 do
    ans:=[op(ans),op(SqCompsMLi(M,L,i1min))];
  od;
  ans;
end proc:

SqCompM:=proc(comp)
 sum(comp[k],k=1..nops(comp));
end proc:
SqCompN:=proc(comp)
 sum((2^k-1)*comp[k],k=1..nops(comp));
end proc:

delAdmisExtensions:=proc(adm,d)
 local i,ans,strt;
 strt:=2;
 if nops(adm)>0 then strt:=2*adm[1]; fi;
 ans:=[];
 for i from strt to (sum(adm[k],k=1..nops(adm))+nops(adm)+d) do
  ans:=[[i,op(adm)],op(ans)];
 od;
 ans;
end proc:

delAdmissables:=proc(maxLength,d)
 local ADMISlist,q,i,ent,j,PostReln;
 ADMISlist:=[]:
 q := queue:-new([]):
 for i to 10000 while queue:-length(q)>0 do
  ent:=queue:-dequeue(q);
   ADMISlist:=[op(ADMISlist),ent];
   if(nops(ent)<maxLength) then
    PostReln:=delAdmisExtensions(ent,d);
   else
    PostReln:=[];
   fi;
   for j to nops(PostReln) do
    queue:-enqueue(q,PostReln[j]);
   od;
 od:
 ADMISlist;
end proc:

I1vulnerable:=proc(I1,d)
 local ans;
 ans:=0;
 if nops(I1)>2 then
  if I1[1]=sum(I1[jJki],jJki=2..nops(I1))+d+nops(I1)-1 then
   ans:=1;
  fi;
 fi;
 ans;
end proc:

I2vulnerable:=proc(I2)
 local ans;
 ans:=0;
 if nops(I2)=0 or I2[nops(I2)]>2 then
  ans:=1;
 fi;
 ans;
end proc:

Esatisfied:=proc(I1,I2,d)
 I1vulnerable(I1,d)* I2vulnerable(I2);
end proc:

multiDimension:=proc(S,d)
 local i,ans,ellR,ennR,N,smr;
 N:=nops(S);ellR:=[];ennR:=[];
 ellR:=map(x->nops(x),S);
 ennR:=map(x->sum(x[smr],smr=1..nops(x)),S);
 ans:=[0,op(ennR)]+[op(ellR),1+ellR[N]+d];
 for i from 3 to N+1 do
  ans[i]:=ans[i]*2^(sum(ellR[smr],smr=1..i-2));
 od;
 ans[N+1]:=ans[N+1]-1;
 ans;
end proc:

multiDimensionAdjusted:=proc(S,d)
 #adjusted so that all but the final entry are inputted in excess-vector format
 local i,ans,ellR,ennR,N,smr;
 N:=nops(S);ellR:=[];ennR:=[];
 ellR:=map(x->nops(x),S);
 ennR:=map(x->add(x[smr+1]*(2^(smr+1)-1),smr=0..nops(x)-1),S);
 ennR[N]:=sum(S[N][smr],smr=1..nops(S[N]));
 ans:=[0,op(ennR)]+[op(ellR),1+ellR[N]+d];
 for i from 3 to N+1 do
  ans[i]:=ans[i]*2^(sum(ellR[smr],smr=1..i-2));
 od;
 ans[N+1]:=ans[N+1]-1;
 ans;
end proc:

tMINUSsAdjusted:=proc(S,d)
 multiDimensionAdjusted(S,d);
 %[nops(%)]-add(%[j],j=1..nops(%)-1);
end proc:

E2DegreeIndecElt:=proc(S,d)
 [0,op(multiDimensionAdjusted(S,d))];
end proc:

E2DegreePRHomElt:=proc(HE,d)
 local ans;
 ans:=[add(HE[r][1],r=1..nops(HE))-1,0,op(add(HE[i][1]*multiDimensionAdjusted(HE[i][2],d),i=1..nops(HE)))];
 ans[nops(ans)]:=ans[nops(ans)]+ans[1];
 ans;
end proc:

Swhat:=proc(elt,d)
 local i,N,T,ans;
 N:=nops(elt);
 T:=add(nops(elt[i]),i=1..N);
 ans:=3; 
 if T>2 then
  ans:=3;
 elif T=0 then
  ans:=0;
 elif T=1 then
  ans:=1;
 elif nops(elt[N])=2 and elt[N][1]=elt[N][2]+d+1 then
  ans:=2;
 fi;
 ans;
end proc:

I1DecomposableTest:=proc(I1,d)
 local ans;
 ans:=0;
 if nops(I1)>1 and I1[1]=sum(I1[jJki],jJki=2..nops(I1))+d+nops(I1)-1 then
   1;
else 0 fi;
end proc:

TrimSListBYst:=proc(sL,smax,tmax,d)
 local ans,i,j,Dm,S,T;
 ans:=[];
 for i to nops(sL) do
  Dm:=multiDimensionAdjusted(sL[i],d);
  S:=add(Dm[j],j=1..nops(Dm)-1);
  T:=Dm[nops(Dm)];
  if T<=tmax and S<=smax then
   ans:=[op(ans),sL[i]];
  fi;
 od;
 ans;
end proc:
TrimSListBYtMINUSs:=proc(sL,tMINUSs,d)
 local ans,i,j,Dm,S,T;
 ans:=[];
 for i to nops(sL) do
  Dm:=multiDimensionAdjusted(sL[i],d);
  S:=add(Dm[j],j=1..nops(Dm)-1);
  T:=Dm[nops(Dm)];
  if T-S=tMINUSs then
   ans:=[op(ans),sL[i]];
  fi;
 od;
 ans;
end proc:
TrimSListBYtMINUSsAndNovelty:=proc(sL,tMINUSs,d)
 local ans,i,j,Dm,S,T;
 ans:=[];
 for i to nops(sL) do
  Dm:=multiDimensionAdjusted(sL[i],d);
  S:=add(Dm[j],j=1..nops(Dm)-1);
  T:=Dm[nops(Dm)];
  if T-S=tMINUSs and Dm[1]>0 then
   ans:=[op(ans),sL[i]];
  fi;
 od;
 ans;
end proc:

TrimPRHomologyListBYst:=proc(sL,smax,tmax,d)
 local ans,i,j,Dm,S,T;
 ans:=[];
 for i to nops(sL) do
  Dm:=E2DegreePRHomElt(sL[i],d);
  S:=add(Dm[j],j=1..nops(Dm)-1);
  T:=Dm[nops(Dm)];
  if T<=tmax and S<=smax then
   ans:=[op(ans),sL[i]];
  fi;
 od;
 ans;
end proc:
TrimPRHomologyListBYtMINUSs:=proc(sL,tMINUSs,d)
 local ans,i,j,Dm,S,T;
 ans:=[];
 for i to nops(sL) do
  Dm:=E2DegreePRHomElt(sL[i],d);
  S:=add(Dm[j],j=1..nops(Dm)-1);
  T:=Dm[nops(Dm)];
  if T-S=tMINUSs then
   ans:=[op(ans),sL[i]];
  fi;
 od;
 ans;
end proc:

TrimPRHomologyListBYtMINUSsAndNovelty:=proc(sL,tMINUSs,d)
 local ans,i,j,Dm,S,T;
 ans:=[];
 for i to nops(sL) do
  Dm:=E2DegreePRHomElt(sL[i],d);
  S:=add(Dm[j],j=1..nops(Dm)-1);
  T:=Dm[nops(Dm)];
  if T-S=tMINUSs and IsX00or00X(Dm)=0 then
   ans:=[op(ans),sL[i]];
  fi;
 od;
 ans;
end proc:

Is00:=proc(L)
 local ans;
 ans:=0;
 if nops(L)>1 and L[1]=0 and L[2]=0 then
  ans:=1;
 fi;
 ans;
end proc: 

IsX00:=proc(L)
 local ans;
 ans:=0;
 if nops(L)>2 and L[3]=0 and L[2]=0 then
  ans:=1;
 fi;
 ans;
end proc: 

IsX00or00X:=proc(L)
 local ans;
 ans:=0;
 if nops(L)>2 and L[3]=0 and L[2]=0 then
  ans:=1;
 fi;
 if nops(L)>1 and L[1]=0 and L[2]=0 then
  ans:=1;
 fi;
 ans;
end proc: 

PRHomologyIterator:=proc(s01,s2,s3,shorterOnes,maxL)
 local ans,numShrt,i,j,ToIns,pos,r;
 ans:=shorterOnes;numShrt:=nops(ans);
 for i to numShrt do
  for j to nops(s01) do
   if ListTools[Search](s01[j],map(x->x[2],ans[i]))=0 then
    ToIns:=sort([op(ans[i]),[1,s01[j]]]);
    if add(ToIns[r][1],r=1..nops(ToIns))<=maxL and ListTools[Search](ToIns,ans)=0 then
     ans:=[op(ans),ToIns];
    fi;
   fi;
  od;
  for j to nops(s2) do
   pos:=ListTools[Search](s2[j],map(x->x[2],ans[i]));
   if pos=0 then
    ToIns:=sort([op(ans[i]),[2,s2[j]]]);
   else
    ToIns:=ans[i];
    ToIns[pos][1]:=ToIns[pos][1]+2;
    ToIns:=sort(ToIns);
   fi;
   if add(ToIns[r][1],r=1..nops(ToIns))<=maxL and ListTools[Search](ToIns,ans)=0 then
    ans:=[op(ans),ToIns];
   fi;
  od;
  for j to nops(s3) do
   pos:=ListTools[Search](s3[j],map(x->x[2],ans[i]));
   if pos=0 then
    ToIns:=sort([op(ans[i]),[1,s3[j]]]);
   else
    ToIns:=ans[i];
    ToIns[pos][1]:=ToIns[pos][1]+1;
    ToIns:=sort(ToIns);
   fi;
   if add(ToIns[r][1],r=1..nops(ToIns))<=maxL and ListTools[Search](ToIns,ans)=0 then
    ans:=[op(ans),ToIns];
   fi;
  od;
 od;
 ans;
end proc:

PrettyPrintSequence:=proc(KE)
local ANS,i,symbls;
 symbls:=[delta,SQa,SQb,SQc,SQd,SQe,SQf,SQg,SQh,SQi,SQj,SQk,SQl,SQm,
                SQn,SQo,SQp,SQq,SQr,SQs,SQt,SQu,SQv,SQw,SQx,SQy,SQz];
 ANS:='e':
 for i from nops(KE) to 1 by -1 do 
  if nops(KE[i])>0 then 
   ANS:=symbls[1+nops(KE)-i][op(ExcessFormatToStandard(KE[i],nops(KE)-i))]*ANS;
  fi;
 od;
 ANS; 
end proc:

PrettyPrintPRelt:=proc(PRelt)
 local ANSr,i;
 if nops(PRelt)>0 then
  ANSr:=omega[PRelt[nops(PRelt)][1]](PrettyPrintSequence(PRelt[nops(PRelt)][2]));
  for i from nops(PRelt)-1 to 1 by -1 do
   ANSr:=omega[PRelt[i][1]](PrettyPrintSequence(PRelt[i][2]))*ANSr;
  od;
 else ANSr:=1;
 fi;
 ANSr;
end proc:

PRHomologyListNovelData:=proc(sL,d)
 local ans,i,j,Dm,S,T;
 ans:=[];
 for i to nops(sL) do
  Dm:=E2DegreePRHomElt(sL[i],d);
  S:=add(Dm[j],j=1..nops(Dm)-1);
  T:=Dm[nops(Dm)];
  if IsX00(Dm)=0 and Dm[1]>-1 then
   ans:=[op(ans),["PR",sL[i],PrettyPrintPRelt(sL[i]),T-S,Dm]];
  fi;
 od;
 ans;
end proc:

IndecListNovelData:=proc(sL,d)
 local ans,i,j,Dm,S,T;
 ans:=[];
 for i to nops(sL) do
  Dm:=multiDimensionAdjusted(sL[i],d);
  S:=add(Dm[j],j=1..nops(Dm)-1);
  T:=Dm[nops(Dm)];
  if Dm[1]>0 then
   ans:=[op(ans),["Ind",sL[i],PrettyPrintSequence(sL[i]),T-S,Dm]];
  fi;
 od;
 ans;
end proc:

CollapseDimensions:=proc(Dm)
 local ans,i,deeT;
 deeT:=Dm;
 ans:=[Dm];
 for i to nops(Dm)-2 do
  deeT:=[deeT[1]+deeT[2],op(deeT[3..nops(deeT)])];
  ans:=[op(ans),deeT];
 od:
 [op(ans),[deeT[2]-deeT[1]]];
end proc:

PrintNData:=proc(inp)
 print(inp[3],"    ",op(map(x->([E[op(x)]]),CollapseDimensions(inp[5]))));
end proc:

ToInsTmS:=proc(ToIns,d)
 E2DegreePRHomElt(ToIns,d);
 %[nops(%)]-add(%[j],j=1..nops(%)-1);
end proc:

PRHomologyIteratorExtraSmart:=proc(s01,s2,s3,shorterOnes,maxTmS,d)
 local ans,numShrt,i,j,ToIns,pos,r;
 ans:=[];numShrt:=nops(shorterOnes);
 for i to numShrt do
  for j to nops(s01) do
   if ListTools[Search](s01[j],map(x->x[2],shorterOnes[i]))=0 then
    ToIns:=sort([op(shorterOnes[i]),[1,s01[j]]]);
    if ToInsTmS(ToIns,d)<=maxTmS and ListTools[Search](ToIns,shorterOnes)=0 then
     ans:=[op(ans),ToIns];
    fi;
   fi;
  od;
  for j to nops(s2) do
   pos:=ListTools[Search](s2[j],map(x->x[2],shorterOnes[i]));
   if pos=0 then
    ToIns:=sort([op(shorterOnes[i]),[2,s2[j]]]);
   else
    ToIns:=shorterOnes[i];
    ToIns[pos][1]:=ToIns[pos][1]+2;
    ToIns:=sort(ToIns);
   fi;
   if ToInsTmS(ToIns,d)<=maxTmS and ListTools[Search](ToIns,shorterOnes)=0 then
    ans:=[op(ans),ToIns];
   fi;
  od;
  for j to nops(s3) do
   pos:=ListTools[Search](s3[j],map(x->x[2],shorterOnes[i]));
   if pos=0 then
    ToIns:=sort([op(shorterOnes[i]),[1,s3[j]]]);
   else
    ToIns:=shorterOnes[i];
    ToIns[pos][1]:=ToIns[pos][1]+1;
    ToIns:=sort(ToIns);
   fi;
   if ToInsTmS(ToIns,d)<=maxTmS and ListTools[Search](ToIns,shorterOnes)=0 then
    ans:=[op(ans),ToIns];
   fi;
  od;
 od;
 ans;
end proc:

PromotePRList:=proc(PRList)
 map(EG->map(EGr->[EGr[1],[[],op(EGr[2])]],EG),PRList);
end proc:

UserFeedback:=proc(Listo)
 local ans,i;
 ans:="";
 for i to nops(Listo) do
  ans:=cat(ans,convert(Listo[i],'string'));
 od;
 writeline(default,ans);
 NULL;
end proc:

ExcessFormatToStandard:=proc(Listo,AmIOn:=1)
 local ans,i;
 if AmIOn>0 then
  ans:=[];
  if nops(Listo)>0 then
   ans:=[Listo[nops(Listo)]];
   for i from nops(Listo)-1 to 1 by -1 do
    ans:=[ans[1]*2+Listo[i],op(ans)];
   od;
  fi;
 else ans:=Listo; fi;
 ans;
end proc:

RemoveFromList:=proc(e,L)
 local s;
 s:=remove(x->x=e,L);
 if nops(L)=nops(s) then
  error "didn't find the element to be removed";
 fi;
 s;
end proc:

AddToList:=proc(e,L)
 if ListTools[Search](e,L)<>0 then
  error "element already in list";
 else
  [op(L),e];
 fi;
end proc:

testIfObviouslyLivesToEinfty:=proc(PRE)
#looks for things detecting divided powers of the fundamental class
 local i,j,k,ans;
 ans:=1;
 for i in PRE while ans=1 do
  if i[1]<>1 or nops(remove(x->x=[],i[2]))>1 or 
  i[2][nops(i[2])]<>[8192,4096,2048,1024,512,256,128,64,32,16,8,4,2][14-nops(i[2][nops(i[2])])..-1]
  then
   ans:=0
  fi;
 od;
 ans;
end proc:

PRIter:=proc(STATZ,maxTmS)
 local ans, newbs, stat, base, olCount, i, j;
 ans:=[[[],0]];
 for j to nops(STATZ) do
  stat:=STATZ[j];
  newbs:=[];
  for base in ans while base[2]+stat[2]*stat[3]<=maxTmS do
   for i to `if`(stat[1]="poly",floor((maxTmS-base[2])/(stat[2]*stat[3])),1) do
    newbs:=[op(newbs),[[op(base[1]),[i*stat[2],j]],base[2]+i*stat[2]*stat[3]]];
   od;
  od;
  ans:=sort([op(ans),op(newbs)],(x,y)->x[2]<y[2]);
 od;
 subsop(1=NULL,ans);
end proc:

###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################

dValue:=2:
calcToDimension:=20:
sMax:=floor(calcToDimension*4/5-1):
tMax:=floor(calcToDimension*9/5-1):
l1Max:=floor(log[2](tMax-dValue+1)):
OutputFileSuffix:=0:

UserFeedback(["Calculating up to the ",calcToDimension,"-stem on the ",dValue,"-sphere"]);
SqList:=[[[]],[[0]]]:
for M from 1 to 11 do
 SqList:=[op(SqList),[op(SqCompsMi(M,0))]];
od:
I2SqList:=[[[]],[]]:
for M from 1 to 11 do
 I2SqList:=[op(I2SqList),[op(SqCompsMi(M,2))]];
od:
I2ListByM:=x->I2SqList[x+2]:
I3ListByM:=x->SqList[x+2]:

UserFeedback(["calculating SLists[N]:=S^(N)"]);
UserFeedback(['N'=1]);
S1ListIgnoreE:=map(x->[x],delAdmissables(l1Max,dValue)):
S1ListIgnoreE:=TrimSListBYst(S1ListIgnoreE,sMax,tMax,dValue):
S1List:=remove(x->I1vulnerable(x[1],dValue)>0,S1ListIgnoreE):
S1List:=TrimSListBYst(S1List,sMax,tMax,dValue):
UserFeedback(['N'=2]);
S2List:=[]:
for i from 1 to nops(S1ListIgnoreE) do
 for m2 from -1 to nops(S1ListIgnoreE[i][1])-1 do
  for j from 1 to nops(I2ListByM(m2)) do
   if Esatisfied(S1ListIgnoreE[i][1],I2ListByM(m2)[j],dValue)=0 then 
    S2List:=[op(S2List),[I2ListByM(m2)[j],op(S1ListIgnoreE[i])]];
   fi;
  od;
 od;
od;
S2List:=TrimSListBYst(S2List,sMax,tMax,dValue):
UserFeedback(['N'=3]);
S3List:=[]:
for i from 1 to nops(S2List) do
 for m3 from -1 to nops(S2List[i][1])-1 do
  for j from 1 to nops(I3ListByM(m3)) do
   S3List:=[op(S3List),[I3ListByM(m3)[j],op(S2List[i])]];
  od;
 od;
od;
S3List:=TrimSListBYst(S3List,sMax,tMax,dValue):
UserFeedback(['N'=4]);
S4List:=[]:
for i from 1 to nops(S3List) do
 for m3 from -1 to nops(S3List[i][1])-1 do
  for j from 1 to nops(I3ListByM(m3)) do
   S4List:=[op(S4List),[I3ListByM(m3)[j],op(S3List[i])]];
  od;
 od;
od;
S4List:=TrimSListBYst(S4List,sMax,tMax,dValue):
SLists:=[S1List,S2List,S3List,S4List,
 [],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]]:
PRLists:=map(x->[[]],SLists):
Indec:=map(x->[],SLists):
for N from 5 to 20 do
 UserFeedback(["N=",N]);
 SNList:=[]:
 for i from 1 to nops(SLists[N-1]) do
  for m3 from -1 to nops(SLists[N-1][i][1])-1 do
   for j from 1 to nops(I3ListByM(m3)) do
    SNList:=[op(SNList), [I3ListByM(m3)[j], op(SLists[N-1][i])]];
   od;
  od;
 od;
 SLists[N]:=TrimSListBYst(SNList,sMax,tMax,dValue);
end do:

S01Lists:=map(y->remove(x->Swhat(x,dValue)>1,y),SLists):
UserFeedback(["cardinalities of S^N_01: ",map(x->nops(x),S01Lists)]);
S1Lists:=map(y->remove(x->Swhat(x,dValue)=0,y),S01Lists):
S2Lists:=map(y->remove(x->Swhat(x,dValue)<>2,y),SLists):
UserFeedback(["cardinalities of S^N_2:  ",map(x->nops(x),S2Lists )]);
S3Lists:=map(y->remove(x->Swhat(x,dValue)<3,y),SLists):
UserFeedback(["cardinalities of S^N_3:  ",map(x->nops(x),S3Lists )]);

###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
################## make modifications here ################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################

statz:=[]:
for LL in S4List do
 TEMPS:=Swhat(LL,dValue);
 if TEMPS<2 then
  statz:=[op(statz),["ext",1,tMINUSsAdjusted(LL,dValue)]];
 elif TEMPS=2 then
  statz:=[op(statz),["poly",2,tMINUSsAdjusted(LL,dValue)]];
 elif TEMPS=3 then
  statz:=[op(statz),["poly",1,tMINUSsAdjusted(LL,dValue)]];
 fi;
od:
statz:

PRITs:=PRIter(statz,calcToDimension):
subinseqs:=map(x->[map(y->[y[1],S4List[y[2]]],x[1]),x[2]],PRITs):
ALLND:=map(XXX->["PR",XXX[1],PrettyPrintPRelt(XXX[1]),XXX[2],E2DegreePRHomElt(XXX[1],dValue)],subinseqs):
ALLND:=remove(x->testIfObviouslyLivesToEinfty(x[2])=1,ALLND):
ALLND:=sort(ALLND,(x,y)->x[4]<y[4]):
ALLNDbrief:=map(inp->
                [inp[3],(map(x->(`if`(nops(x)=1, pi[x[1]], E[op(x)])),
                             (CollapseDimensions(inp[5]))))],ALLND):
if OutputFileSuffix=0 then
 interface(rtablesize=20000): print(Matrix(ALLNDbrief));
else
 latex(Matrix(ALLNDbrief),cat("C:/Users/Michael/Desktop/latexForTables/tableRawData",OutputFileSuffix,".tex"));
 UserFeedback(["output saved to ",
               cat("C:/Users/Michael/Desktop/latexForTables/tableRawData",OutputFileSuffix,".tex")]);
fi:
UserFeedback(["calculated ",nops(ALLNDbrief)," elements up to the ",calcToDimension,"-stem"]);

