new_dlog:=proc()
 global LogFilename,outputStream,outputStreamOpenFlag;
 if not type(outputStreamOpenFlag,'integer') then
  outputStreamOpenFlag:=-1;
 fi;
 if outputStreamOpenFlag=-1 then
  LogFilename:=StringTools[FormatTime]("c:/maple_logs/%d%b_%H%M%S.txt");
  outputStream:=fopen(LogFilename,WRITE);
  outputStreamOpenFlag:=1;
 elif outputStreamOpenFlag=0 then
  error "you've already opened and closed the file - use reopen_dlog()";
 elif outputStreamOpenFlag=1 then
  error "the file is already open!"
 fi;
 return NULL;
end proc:
close_dlog:=proc()
 global LogFilename,outputStream,outputStreamOpenFlag;
 if outputStreamOpenFlag<>1 then
  if outputStreamOpenFlag=0 then
   error "the file has already been closed";
  else
   error "the file probably never existed";
  fi;
 else
  fclose(LogFilename);
  outputStreamOpenFlag:=0;
 fi;
 return NULL;
end proc:
reopen_dlog:=proc()
 global LogFilename,outputStream,outputStreamOpenFlag;
 if outputStreamOpenFlag<>0 then
  if outputStreamOpenFlag=1 then
   error "the file is open already";
  else
   error "the file probably never existed";
  fi;
 else
  outputStream:=fopen(LogFilename,APPEND);
  outputStreamOpenFlag:=1;
 fi;
 return NULL;
end proc:
add_to_dlog:=proc(obj)
 global LogFilename,outputStream,outputStreamOpenFlag;
 if outputStreamOpenFlag<>1 then
  if outputStreamOpenFlag=0 then
   error "the file has been closed";
  else
   error "the file probably never existed";
  fi;
 else
  fprintf(outputStream, cat(convert(obj,string),"\n"));
 fi;
 return NULL;
end proc:

set_dimensions:=proc(cTD,d)
 global calcToDimension,dValue;
 calcToDimension:=cTD;dValue:=d;
 return NULL;
end proc:

build_RL:=proc()
 global RL,calcToDimension,dValue;
 local I1list,I2lists,I3lists,newInterface,ans,ILIST,inclusionLists,
       inclusionList,oldInterface,prevLength,m,ISEQ,tempo;
 I1list:=delAdmissablesByMaxSum(calcToDimension,dValue):
 I3lists:=[seq(SqCompsMi(M,0),M=-1..11)]:
 I2lists:=[seq(SqCompsMi(M,2),M=-1..11)]:
 newInterface:=[seq(2^(i+1)+dValue-2,i=1..max(seq(nops(I1list[i]),i=1..nops(I1list))))];
 inclusionLists:=[];
 for ILIST in [I2lists,I3lists,I3lists,I3lists,I3lists,I3lists,I3lists,I3lists] do
  inclusionList:=[];
  oldInterface:=remove(x->x=2^31-1,newInterface):
  newInterface:=map(x->2^31-1,oldInterface):
  for prevLength from 1 to nops(oldInterface) do
   m:=prevLength - 1;
   for ISEQ in ILIST[m+2] do
    tempo:=2^(nops(ISEQ))*oldInterface[m+1]
           +(2^(nops(ISEQ))-1)*(m+2)
           -nops(ISEQ)-add((2^i-1)*ISEQ[i],i=1..nops(ISEQ));
    if tempo<=calcToDimension and tempo<newInterface[nops(ISEQ)] then
     newInterface[nops(ISEQ)]:=tempo;
    fi;
    if tempo<calcToDimension then
     inclusionList:=[op(inclusionList),ISEQ]
    fi;
   od;
  od:
  #print("interface ",newInterface);  print("list ",inclusionList);  print("");
  if nops(inclusionList)<>0 then
   inclusionLists:=[[[],op(inclusionList)],op(inclusionLists)];
  fi;
 od:
 RL:=[op(inclusionLists),map(ExcessFormatSingle,I1list)];
 return NULL;
end proc:

find_RL_coordinates:=proc(S)
 global RL;
 local i,ans,T;
 if nops(S)>nops(RL) then
  error "the sequence is too long";
 fi; 
 ans:=[];
 for i from -1 to -nops(S) by -1 do
   T:=ListTools[Search](S[i],RL[i]);
   if T=0 then return 0; fi;
   ans:=[T,op(ans)];
 od;
 for i from -1-nops(S) to -nops(RL) by -1 do
   ans:=[1,op(ans)];
 od;
 ans;
end proc;

StatMat_TravIns_starter:=proc()
 global calcToDimension,dValue,RL;
 local RLs,outTable,pTable,i,j,excess,I2Evul,newDimn,pLastLoc,pInitLoc;
 RLs:=[op(RL[1..-2]),map(unExcessFormatSingle,RL[-1])];
 outTable:=rtable(1..nops(RLs[-2]),1..nops(RLs[-1]),storage=sparse);
 pTable:=rtable(1..nops(RLs[-2]),1..nops(RLs[-1]),storage=sparse);
 pInitLoc:="finished";
 for i to nops(RLs[-2]) do
  excess:=`if`(RLs[-2][i]=[],-1,add(RLs[-2][i][j],j=1..nops(RLs[-2][i])));
  I2Evul:=I2vulnerable(RLs[-2][i]);
  for j to nops(RLs[-1]) do
   if excess<nops(RLs[-1][j]) and I2Evul*I1vulnerable(RLs[-1][j],dValue)=0 then
    newDimn:=tMINUSsAdjusted([RLs[-2][i],RLs[-1][j]],dValue);
    if newDimn<=calcToDimension then
     outTable[i,j]:=newDimn;
     if pInitLoc="finished" then
      pInitLoc:=[i,j]; 
     else
      pTable[op(pLastLoc)]:=[i,j];
     fi;
     pLastLoc:=[i,j];
    fi;
   fi;
  od;
 od;
 pTable[op(pLastLoc)]:="finished";
 return [outTable,pTable,pInitLoc];
end proc:

build_StatMat_TravIns:=proc(DataSoFar:="none")
 global StatMat,TravIns,calcToDimension,dValue,RL;
 local outTable,cp,fInds,iInd,currRLlen,prevRLlen,currRLdim,currRLexc,
       newDimn,iterDims,pTable,pInitLoc,pLastLoc,DSFsize,T;
 if DataSoFar="none" then
  if map(x->x[1],RL)<>map(x->[],RL) then
   error "need RL[i][1]=[] for all i";
  fi;
  return build_StatMat_TravIns(StatMat_TravIns_starter());
 fi;
 DSFsize:=rtable_num_dims(DataSoFar[1]);
 if DSFsize=nops(RL) then
  StatMat:=DataSoFar[1];
  TravIns:=[DataSoFar[2],DataSoFar[3]];
  T:=TravIns[2];
  while T<>"finished" do
   StatMat[op(T)]:=[1,StatMat[op(T)]];
   T:=TravIns[1][op(T)];
  od:
  return NULL;
 fi;
 outTable:=rtable(1..nops(RL[-1-DSFsize]),
                  rtable_dims(DataSoFar[1]),storage=sparse);
 pTable:=rtable(rtable_dims(outTable),storage=sparse);
 pInitLoc:="finished";
 currRLlen:=map(x->nops(x),RL[-1-DSFsize]);
 prevRLlen:=map(x->nops(x),RL[-DSFsize]);
 currRLdim:=map(x->add((2^i-1)*x[i],i=1..nops(x)),
                RL[-1-DSFsize]);
 currRLexc:=map(x->`if`(x=[],-1,add(x[i],i=1..nops(x))),
                RL[-1-DSFsize]);
 fInds:=DataSoFar[3];
 while fInds<>"finished" do
   for iInd to nops(currRLlen) do
    if currRLexc[iInd]<prevRLlen[fInds[1]] then
     newDimn:=(2^(currRLlen[iInd])  )*DataSoFar[1][op(fInds)]
             +((2^(currRLlen[iInd]))-1)*(prevRLlen[fInds[1]]+1)
             -currRLlen[iInd]-currRLdim[iInd];
#     UserFeedback([RL[-1-DSFsize][iInd],seq(RL[i][fInds[i]],i=-DSFsize..-1)]);
     if newDimn<=calcToDimension then
      outTable[iInd,op(fInds)]:=newDimn;
      if pInitLoc="finished" then
       pInitLoc:=[iInd,op(fInds)]; 
      else
       pTable[op(pLastLoc)]:=[iInd,op(fInds)];
      fi;
      pLastLoc:=[iInd,op(fInds)];
     fi;
    fi;
   od;
   fInds:=DataSoFar[2][op(fInds)];
 od;
 pTable[op(pLastLoc)]:="finished";
 return build_StatMat_TravIns([outTable,pTable,pInitLoc]);
end proc:

double_class:=proc(inds)
 global StatMat;
 if StatMat[op(inds)][1]<>0 then
  StatMat[op(inds)][1]:=2*StatMat[op(inds)][1];
 else
  error "this class is dead";
 fi;
 return NULL;
end proc:

kill_class:=proc(inds)
 global StatMat;
 if StatMat[op(inds)][1]<>0 then
  StatMat[op(inds)]:=0;
 else
  error "this class is already dead";
 fi;
 return NULL;
end proc:

rectify_TravIns_find_LD:=proc()
 global StatMat,TravIns,LowestDimension;
 local T;
 LowestDimension:=2^31-1;
 T:=TravIns[2];
 while T<>"finished" and StatMat[op(T)]=0 do
  TravIns[2]:=TravIns[1][op(T)];
  T:=TravIns[2];
 od;
 while T<>"finished" do
  LowestDimension:=min(LowestDimension,StatMat[op(T)][1]*StatMat[op(T)][2]);
  if TravIns[1][op(T)]<>"finished" and StatMat[op(TravIns[1][op(T)])]=0 then
   TravIns[1][op(T)]:=TravIns[1][op(TravIns[1][op(T)])]:
  else
   T:=TravIns[1][op(T)];
  fi;
 od:
 return NULL;
end proc:

assign_OM_lowest_classes:=proc(numDimsToPrint:=2)
 #automatically runs rectify_TravIns_find_LD beforehand
 global StatMat,TravIns,LowestDimension,OM;
 local T,L,i;
 rectify_TravIns_find_LD();
 L:=[];
 T:=TravIns[2];
 while T<>"finished" do
  if StatMat[op(T)][1]*StatMat[op(T)][2] <= LowestDimension+numDimsToPrint-1 then
   L:=[op(L),T];
  fi;
  T:=TravIns[1][op(T)];
 od;
 #L:=map(x->[x,remove(y->y=[],[seq(RL[i][x[i]],i=1..nops(x))]),op(StatMat[op(x)])],L);
 L:=map(x->[x,remove(y->y=[],[seq(RL[i][x[i]],i=1..nops(x))]),op(StatMat[op(x)]),StatMat[op(x)][1]*StatMat[op(x)][2],
            2^(add(nops(RL[i][x[i]]),i=1..nops(x)-1))*StatMat[op(x)][1]*(dValue+1+nops(RL[-1][x[-1]])+add(RL[-1][x[-1]][j]*(2^j-1),j=1..nops(RL[-1][x[-1]])))-1   ],L);
 #[1=location,2=printout,3=power,4=dimensionOfFirstPower,5=t-s,6=t]
 L:=map(x->[op(x),x[6]-x[5],PrettyPrintPRelt([[x[3],x[2]]])   ,   E2DegreePRHomEltNoZero(unExcessFormatPR([[x[3],x[2]]]),dValue)],L);
 #[...,7=s,8=prettyprint,9=allE2dimensions(forDebug)]
 L:=sort(L,(x,y)->(x[5]<y[5] or 
                           (x[5]=y[5] and x[6]<y[6])) or
                           (x[5]=y[5] and x[6]=y[6] and
  lexorder(StringTools[Reverse](convert(ListTools[Flatten](x[2]),string)),
           StringTools[Reverse](convert(ListTools[Flatten](y[2]),string)))
                            )):
 for i to nops(L) do
  L[i]:=[op(L[i]),i];
 od;
 L:=[['loc',`elt`,`power`,`1powDim`,`t-s`,`t`,`s`,`elt`,`dims`,` `],op(L)];
 OM:=Matrix(L);
 return NULL;
end proc:

print_OM:=proc(outputVector:=[10,1,2,3,8,7,5])
 global OM;
 print(LinearAlgebra[SubMatrix](OM,[1..-1],outputVector));
end proc:

diff_extractor:=proc(TR,SR,outputVector:=[10,1,2,3,8,7,5])
 global OM;
 print(LinearAlgebra[SubMatrix](OM,[1,TR+1,SR+1],outputVector));
 #why not test somthing at this point?
 [`?`,cat("d",OM[TR+1,7]-OM[SR+1,7]),OM[SR+1,2],OM[SR+1,3],OM[TR+1,2],OM[TR+1,3],OM[SR+1,1],OM[TR+1,1]];
end proc:

trim_off_Einfty_classes:=proc()
 global StatMat,TravIns,dValue,RL;
 local i;
 kill_class([seq(1,i=1..nops(RL))]);
 for i from 2 to nops(RL[-1]) do
  if remove(x->x=0,RL[-1][i])=[dValue] and RL[-1][i][-1]=dValue then
   double_class([seq(1,i=1..nops(RL)-1),i]);  
  fi;
 od;
end proc:

implement_diff:=proc(difl,logme:=false)
 global RL,StatMat;
 if nops(StatMat[op(difl[7])])<>2 or nops(StatMat[op(difl[8])])<>2 then
  error "either source or target is already dead or broken";
 fi;
 if difl[4]<>StatMat[op(difl[7])][1] then
  error "the source power is wrong";
 fi;
 if difl[6]<>StatMat[op(difl[8])][1] then
  error "the target power is likely to be wrong";
 fi;
 kill_class(difl[8]);
 double_class(difl[7]);
 if logme<>false then
  dlog(difl);
 fi;
 return NULL;
end proc:


set_dimensions(120,2);
build_RL();
build_StatMat_TravIns();
trim_off_Einfty_classes();
assign_OM_lowest_classes();
print_OM();
diff_extractor(1,2);


