restart; with(CodeTools[Profiling]):

interface(rtablesize=2000):
SqCompsMi:=proc(M,i1min)
  local ans,L;
  ans:=[];
  if M=-1 then return [[]]; fi;
  for L from 1 to M-i1min+1 do
    ans:=[op(ans),
          op( map(xx->xx+[seq(0,dummy=1..L-1),i1min-1],
                  sort([op(combinat[composition](M-(i1min-1), L))],
                       (x,y)->lexorder(convert(x,string),convert(y,string))
                      )
                 ) 
            )];
  od;
  ans;
end proc:
ExcessFormatSingle:=y->`if`(y=[],[], [seq(y[i-1]-2*y[i],i=2..nops(y)),y[-1]]):
unExcessFormatSingle:=proc(y)
 local j,ans;
 ans:=y;
 for j from nops(y)-1 to 1 by -1 do
  ans[j]:=ans[j]+2*ans[j+1];
 od:
 return ans;
end proc:
UserFeedback:=proc()
 local ans,x;ans:="";
 for x in args do ans:=cat(ans,convert(x,'string'));od;
 writeline(default,ans); return NULL;
end proc:

#calcToDimension, dValue, Root, delta_admissables, predecessor_data, RL, nops_RL, RLlookup,
#StatMat, TravIns, diffCounter, LowestDimension, OM
#
#new_dlog()
#force_new_dlog()
#close_dlog()
#reopen_dlog()
#ensure_dlog_open()
#save_dlog(loud:=true)
#dlog()
#timed_message()
#timed_dlog()
#savefile_name()
#
#set_dimensions_and_Root(cTd,d,rt:=[])
#build_RL_and_RLlookup()
#StatMat_TravIns_starter()
#build_StatMat_TravIns(DataSoFar:="none")
#*strip_subroot_classes_from_TravIns()
#rectify_and_find_LD_and_strip_low_dim_subroot_classes_from_TravIns()
#rectify_TravIns_find_LD_ignoring_subroot:=proc()
#trim_off_00002_001002_classes()
#delta_admissables_by_max_sum_using_stack(maxSum,d)
#build_delta_admissables_with_predecessor_data(maxSum,d)
#build_delta_admissables_with_Root_and_PD(maxSum,d)
#
#rectify_TravIns_find_LD()
#assign_OM(numDimsToPrint:=2)
#pretty_print_power_of_sequence(KE,pow)
#print_OM(outputVector:=[10,8,7,5])
#assign_and_print_OM(numDimsToPrint:=2,outputVector:=[10,8,7,5])
#diff_extractor(TR,SR,outputVector:=[10,8,7,5])
#quick_extract_and_store_diffs()
#quick_extract_and_store_initial_diff_string(len,sourceStarts:="no gap")
#apply_stored_diffs_and_assign_and_print_OM(numDimsToPrint:=2,outputVector:=[10,8,7,5])
#
#*find_RL_coordinates(S)
#*find_RL_coordinates_with_hints(S,hints:=[])
#find_RL_coordinates_with_consecutive_hints(S,hints:=[])
#differential_coords_finder_ints_guaranteed(diff,sEqualityPositions,tEqualityPositions)
#
#*double_class(inds)
#kill_class(inds)
#double_rMinusOne(dwhat)
#UP(diff,sDescriptor,sData,tDescriptor,tData) (formerly differential_upgrader)
#*differential_squarer(diff)
#all_ordered_partitions_with_sum_at_most(mAx)
#
#*implement_diff(difl)
#*implement_diff_if_in_range_TF(difl)
#*implement_diff_if_in_range_TF_with_some_squares(difl,numSquares:=2^31-1)
#IM(difl) (formerly "implement_diff_and_all_squares_if_in_range_TF_quick")
#string_of_length_one_sequences_for_squares_index_finder(N_so_far,most_recent_length)
#
#first_round_of_differentials()
#second_round_of_differentials()
#autowipe()

#*=out of date

new_dlog:=proc()
 global LogFilename,outputStream,outputStreamOpenFlag;
 if not type(outputStreamOpenFlag,'integer') then
  outputStreamOpenFlag:=-1;
 fi;
 if outputStreamOpenFlag=-1 then
  LogFilename:=StringTools[FormatTime]("c:/maple_logs/%m%d_%H%M%S.txt");
  outputStream:=fopen(LogFilename,WRITE);
  outputStreamOpenFlag:=1;
  timed_message("new dlog opened (",LogFilename,")");
 elif outputStreamOpenFlag=0 then
  error "you've already opened and closed the file - use reopen_dlog()";
 elif outputStreamOpenFlag=1 then
  error "the file is already open!"
 fi;
 return NULL;
end proc:
force_new_dlog:=proc()
 global LogFilename,outputStream,outputStreamOpenFlag;
 if outputStreamOpenFlag=1 then
  close_dlog();
 fi;
 if outputStreamOpenFlag=0 then
  outputStreamOpenFlag:="forcing new dlog";
  timed_message("abandoning old dlog (",LogFilename,")");
 fi;
 new_dlog();
 return NULL;
end proc:
close_dlog:=proc()
 global LogFilename,outputStream,outputStreamOpenFlag;
 if outputStreamOpenFlag<>1 then
  if outputStreamOpenFlag=0 then
   error "the file has already been closed";
  else
   error "the file probably never existed";
  fi;
 else
  fclose(LogFilename);
  outputStreamOpenFlag:=0;
  timed_message("dlog closed (",LogFilename,")");
 fi;
 return NULL;
end proc:
reopen_dlog:=proc()
 global LogFilename,outputStream,outputStreamOpenFlag;
 if outputStreamOpenFlag<>0 then
  if outputStreamOpenFlag=1 then
   error "the file is open already";
  else
   error "the file probably never existed";
  fi;
 else
  outputStream:=fopen(LogFilename,APPEND);
  outputStreamOpenFlag:=1;
  timed_message("dlog reopened (",LogFilename,")");
 fi;
 return NULL;
end proc:
ensure_dlog_open:=proc()
 if outputStreamOpenFlag=0 then
  reopen_dlog();
 elif outputStreamOpenFlag<>1 then
  new_dlog();
 fi;
end proc:
save_dlog:=proc(loud:=true)
 global LogFilename,outputStream,outputStreamOpenFlag;
 if outputStreamOpenFlag<>1 then
  if outputStreamOpenFlag<>0 then
   error "the file probably never existed";
  fi;
 else
  fclose(LogFilename);
  outputStream:=fopen(LogFilename,APPEND);
  if loud=true then timed_message("dlog closed and reopened (",LogFilename,")");fi;
 fi;
 return NULL;
end proc:
dlog:=proc(obj,end_entry_string:=",\n")
 global LogFilename,outputStream,outputStreamOpenFlag;
 if outputStreamOpenFlag<>1 then
  if outputStreamOpenFlag=0 then
   error "the file has been closed";
  else
   error "the file probably never existed";
  fi;
 else
  fprintf(outputStream, cat(convert(obj,string),end_entry_string));
 fi;
 return NULL;
end proc:
timed_message:=proc()
 UserFeedback(StringTools[FormatTime]("%H:%M:%S: "),args);
end proc:
timed_dlog:=proc()
 local ans,i,Listo;Listo:=[args];
 ans:=StringTools[FormatTime]("%a%l:%M:%S%p: ");
 for i to nops(Listo) do
  ans:=cat(ans,convert(Listo[i],'string'));
 od;
 dlog(ans);
 NULL;
end proc:
savefile_name:=proc()
 global dValue,calcToDimension,Root;
 local ans,i;
 ans:="C:\\maple_output\\afterRound2_S";
 ans:=cat(ans,dValue);
 ans:=cat(ans,"CtD");
 ans:=cat(ans,calcToDimension);
 if Root<>[] then
  ans:=cat(ans,"Root");
  for i in Root do
   ans:=cat(ans,convert(i,string));
  od;
 fi;
 for i in args do
  ans:=cat(ans,convert(i,string));
 od;
 return ans;
end proc:

set_dimensions_and_Root:=proc(cTD,d,rt:=[])
 global calcToDimension,dValue,num_of_squarings_calculator,Root;
 local L,MinDeg,storeddim,i;
 forget(num_of_squarings_calculator);
 calcToDimension:=cTD;dValue:=d;Root:=rt;
 timed_message("set dimensions: up to the ",calcToDimension,"-stem on the ",dValue,"-sphere");
 if Root<>[] then
  timed_message("the root has been set to ",Root);
  L:=unExcessFormatSingle(Root);
  MinDeg:=L[nops(L)];
  storeddim:=0;
  for i by -1 from nops(L)-1 to 1 do
   storeddim:=storeddim+L[i+1]+1;
   MinDeg:=max(MinDeg,L[i]-storeddim);
  od;
  if MinDeg>d then
   error "I don't think that this class is unstable";
  fi;
 fi;
 return NULL;
end proc:

delta_admissables_by_max_sum_using_stack:=proc(maxSum,d)
 local ADMISlist,AMLcount,q,ent,j,PostReln,sumSoFar;
 ADMISlist:=Table(): AMLcount:=0:
 q := stack[new]([]):
 while not stack[empty](q) do
  ent:=stack[pop](q);
  AMLcount:=AMLcount+1:
  ADMISlist[AMLcount]:=ent;
  sumSoFar:=add(ent[k],k=1..nops(ent));
  for j from min(maxSum-sumSoFar,(sumSoFar+nops(ent)+d))
          to `if`(nops(ent)>0,2*ent[1],2) by -1 do
   stack[push]([j,op(ent)],q);
  od;
 od:
 [seq(ADMISlist[j],j=1..AMLcount)];
end proc:

build_delta_admissables_with_Root_and_PD:=proc(maxSum,d)
#enter the root in excess format
#this will leave RL[-1][1] the result of stripping an element off the root
#this is a placeholder - most desirable is to leave it in the computation
#until after the StatMat, etc are done and then to remove it from TravIns.
 local ADMISlist,AMLcount,q,ent,j,PostReln,sumSoFar,RootNONexcess;
 global delta_admissables,predecessor_data,Root;
 if Root=[] then
  build_delta_admissables_with_predecessor_data(maxSum,d);
  return NULL;
 fi;
 RootNONexcess:=unExcessFormatSingle(Root);
 ADMISlist:=Table(): AMLcount:=1:
 ADMISlist[1]:=[RootNONexcess[2..-1],0];
 q := stack[new]([RootNONexcess,1]):
 while not stack[empty](q) do
  ent:=stack[pop](q);
  AMLcount:=AMLcount+1:
  ADMISlist[AMLcount]:=ent;
  sumSoFar:=add(ent[1][k],k=1..nops(ent[1]));
  for j from min(maxSum-sumSoFar,(sumSoFar+nops(ent[1])+d))
          to `if`(nops(ent[1])>0,2*ent[1][1],2) by -1 do
   stack[push]([[j,op(ent[1])],AMLcount],q);
  od;
 od:
 delta_admissables:=[seq(ExcessFormatSingle(ADMISlist[j][1]),j=1..AMLcount)];
 #so that delta_admissables ends up in excess form!
 predecessor_data:=[seq(ADMISlist[j][2],j=1..AMLcount)];
 return NULL;
end proc:

build_delta_admissables_with_predecessor_data:=proc(maxSum,d)
 local ADMISlist,AMLcount,q,ent,j,PostReln,sumSoFar;
 global delta_admissables,predecessor_data;
 ADMISlist:=Table(): AMLcount:=0:
 q := stack[new]([[],0]):
 while not stack[empty](q) do
  ent:=stack[pop](q);
  AMLcount:=AMLcount+1:
  ADMISlist[AMLcount]:=ent;
  sumSoFar:=add(ent[1][k],k=1..nops(ent[1]));
  for j from min(maxSum-sumSoFar,(sumSoFar+nops(ent[1])+d))
          to `if`(nops(ent[1])>0,2*ent[1][1],2) by -1 do
   stack[push]([[j,op(ent[1])],AMLcount],q);
  od;
 od:
 delta_admissables:=[seq(ExcessFormatSingle(ADMISlist[j][1]),j=1..AMLcount)];
 #so that delta_admissables ends up in excess form!
 predecessor_data:=[seq(ADMISlist[j][2],j=1..AMLcount)];
 return NULL;
end proc:

build_RL_and_RLlookup:=proc()
 global RL,nops_RL,calcToDimension,dValue,
        string_of_length_one_sequences_for_squares_index_finder,
        RLlookup,delta_admissables,predecessor_data;
 local I2lists,I3lists,newInterface,ans,ILIST,inclusionLists,
       inclusionList,oldInterface,prevLength,m,ISEQ,tempo,i,j;
 forget(string_of_length_one_sequences_for_squares_index_finder);
 timed_message("building RL for calculation up to dimension ",calcToDimension);
 build_delta_admissables_with_Root_and_PD(calcToDimension,dValue);
 I3lists:=[seq(SqCompsMi(M,0),M=-1..11)]:
 I2lists:=[seq(SqCompsMi(M,2),M=-1..17)]:
 newInterface:=[seq(2^(i+1)+dValue-2,i=1..max(seq(nops(delta_admissables[i]),i=1..nops(delta_admissables))))];
 inclusionLists:=[];
 for ILIST in [I2lists,I3lists,I3lists,I3lists,I3lists,I3lists,I3lists,I3lists,
               I3lists,I3lists,I3lists,I3lists,I3lists,I3lists,I3lists,I3lists] do
  inclusionList:=[];
  oldInterface:=remove(x->x=2^31-1,newInterface):
  newInterface:=map(x->2^31-1,oldInterface):
  for prevLength from 1 to nops(oldInterface) do
   m:=prevLength - 1;
   if m+2>nops(ILIST) then
    error cat("you need to extend ",`if`(ILIST=I2lists,"I2lists","I3lists"));
   fi;
   for ISEQ in ILIST[m+2] do
    tempo:=2^(nops(ISEQ))*oldInterface[m+1]
           +(2^(nops(ISEQ))-1)*(m+2)
           -nops(ISEQ)-add((2^i-1)*ISEQ[i],i=1..nops(ISEQ));
    if tempo<=calcToDimension and tempo<newInterface[nops(ISEQ)] then
     newInterface[nops(ISEQ)]:=tempo;
    fi;
    if tempo<calcToDimension then
     inclusionList:=[op(inclusionList),ISEQ]
    fi;
   od;
  od:
  #print("interface ",newInterface);  print("list ",inclusionList);  print("");
  if nops(inclusionList)<>0 then
   inclusionLists:=[[[],op(inclusionList)],op(inclusionLists)];
  fi;
 od:
 RL:=[op(inclusionLists),delta_admissables];
 nops_RL:=nops(RL);
 timed_message("built RL[1..",nops_RL,"] with dimensions ",map(x->nops(x),RL));
 RLlookup:=Table();
 for i from -2 to -nops_RL by -1 do
  for j from 1 to nops(RL[i]) do
   RLlookup(i,op(RL[i][j])):=j;
  od;
 od: 
 timed_message("built lookup table inverting RL:{-2,...,-",nops_RL,"}*N-->seq");
 return NULL;
end proc:

find_RL_coordinates:=proc(S)
 global RL,nops_RL,RLlookup;
 local i,ans,T;
 if nops(S)>nops_RL then
  return 0;
 fi; 
 ans:=[];
 for i from -1 to -nops(S) by -1 do
   T:=RLlookup(i,op(S[i]));
   if not type(T,'integer') then return 0; fi;
   ans:=[T,op(ans)];
 od;
 return [seq(1,asd=1..(nops_RL-nops(S))),op(ans)];
end proc:


find_RL_coordinates_with_hints:=proc(S,hints:=[])
 #hints is a list like [[-3,5],[-2,47]] indicating some known positions
 #which must be indexed by negative numbers like -2 and -3 to work
 global RL,nops_RL,RLlookup;
 local i,ans,T,hfind;
 if nops(S)>nops_RL then
  return 0;
 fi; 
 ans:=[];
 for i from -1 to -nops(S) by -1 do
   hfind:=ListTools[Search](i,map(x->x[1],hints));
   if hfind=0 then
    T:=RLlookup(i,op(S[i]));
    if not type(T,'integer') then return 0; fi;
   else
    T:=hints[hfind][2];
    if T=0 then return 0; fi;
   fi;
   ans:=[T,op(ans)];
 od;
 return [seq(1,asd=1..(nops_RL-nops(S))),op(ans)];
end proc:

find_RL_coordinates_with_consecutive_hints:=proc(S,hints:=[])
 #hints is a list like [2,5,47] indicating the rightmost positions
 global RL,nops_RL,RLlookup;
 local i,ans,RLglance;
 ans:=hints;
 for i from -1-nops(hints) to -nops(S) by -1 do
  RLglance:=RLlookup(i,op(S[i]));
  if not type(RLglance,'integer') then return 0; fi;
  ans:=[RLglance,op(ans)];
 od;
 return [seq(1,asd=1..(nops_RL-nops(S))),op(ans)];
end proc:

StatMat_TravIns_starter:=proc()
 global calcToDimension,dValue,RL;
 local RLs,outTable,pTable,i,j,excess,I2Evul,newDimn,pLastLoc,pInitLoc,I1vulnerabilities,I1lengths,
       I1tMs,I2vulnerabilities,I2ellPlusEnn2,I2exc,I2lengths;
 outTable:=rtable(1..nops(RL[-2]),1..nops(RL[-1]),storage=sparse);
 pTable:=rtable(1..nops(RL[-2]),1..nops(RL[-1]),storage=sparse);
 I1vulnerabilities:=map(x->evalb(nops(x)>2 and add(x[i],i=1..nops(x))=dValue+nops(x)-1),RL[-1]);
 I1lengths:=map(x->nops(x),RL[-1]);
 I1tMs:=map(x->dValue+add((2^i-1)*x[i],i=1..nops(x)),RL[-1]);
 I2vulnerabilities:=map(x->evalb(x=[] or x[-1]>2) ,RL[-2]);
 I2ellPlusEnn2:=map(x->nops(x)+add((2^i-1)*x[i],i=1..nops(x)),RL[-2]);
 I2exc:=map(x->`if`(x=[],-1,add(x[i],i=1..nops(x))),RL[-2]);
 I2lengths:=map(x->nops(x),RL[-2]);
 pInitLoc:="finished";
 for i to nops(RL[-2]) do
  for j to nops(RL[-1]) do
   if I2exc[i]<I1lengths[j] and not (I1vulnerabilities[j] and I2vulnerabilities[i]) then
    newDimn:=2^(I2lengths[i])*(I1tMs[j]+I1lengths[j]+1)-(I1lengths[j]+1)-I2ellPlusEnn2[i];
    if newDimn<=calcToDimension then
     outTable[i,j]:=newDimn;
     if pInitLoc="finished" then
      pInitLoc:=[i,j]; 
     else
      pTable[op(pLastLoc)]:=[i,j];
     fi;
     pLastLoc:=[i,j];
    fi;
   fi;
  od;
 od;
 pTable[op(pLastLoc)]:="finished";
 timed_message("calculated StatMat_TravIns_starter");
 return [outTable,pTable,pInitLoc];
end proc:

build_StatMat_TravIns:=proc(DataSoFar:="none")
 global StatMat,TravIns,calcToDimension,dValue,Root,RL,nops_RL,diffCounter;
 local outTable,cp,fInds,iInd,currRLlen,prevRLlen,currRLdim,currRLexc,
       newDimn,iterDims,pTable,pInitLoc,pLastLoc,DSFsize,T,lengthToGo,
       prevLength,currDim,iInds,DEPTH,prevRLlen_finds1,DSF1;
 if DataSoFar="none" then
  timed_message("commencing build of StatMat and TravIns");
  diffCounter:=0;
  if Root<>[] then
   if map(x->x[1],RL)[1..-2]<>map(x->[],RL)[1..-2] or RL[-1][1]<>Root[2..-1] then
    error "need RL[i][1]=[] for all i<-1 and RL[-1][1]=Root[2..-1]";
   fi;
  else
   if map(x->x[1],RL)<>map(x->[],RL) or RL[-1][1]<>[] then
    error "need RL[i][1]=[] for all i<-1 and RL[-1][1]=Root[2..-1]";
   fi;
  fi;
  return build_StatMat_TravIns(StatMat_TravIns_starter());
 fi;
 DSFsize:=rtable_num_dims(DataSoFar[1]);
 if DSFsize=nops_RL then
  StatMat:=DataSoFar[1];
  TravIns:=[DataSoFar[2],DataSoFar[3]];
  T:=TravIns[2];
  while T<>"finished" do
   StatMat[op(T)]:=[1,StatMat[op(T)]];
   T:=TravIns[1][op(T)];
  od:
  timed_message("StatMat and TravIns done, dimensions ",map(x->[seq(i,i=x)][-1],[rtable_dims(StatMat)]));
  return NULL;
 fi;
 outTable:=rtable(1..nops(RL[-1-DSFsize]),
                  rtable_dims(DataSoFar[1]),storage=sparse);
 pTable:=rtable(rtable_dims(outTable),storage=sparse);
 pInitLoc:="finished";
 currRLlen:=map(x->nops(x),RL[-1-DSFsize]);
 prevRLlen:=map(x->nops(x),RL[-DSFsize]);
 currRLdim:=map(x->add((2^i-1)*x[i],i=1..nops(x)),
                RL[-1-DSFsize]);
 currRLexc:=map(x->`if`(x=[],-1,add(x[i],i=1..nops(x))),
                RL[-1-DSFsize]);
 fInds:=DataSoFar[3];
 if nops(currRLlen)>2 then
  while fInds<>"finished" do
   prevRLlen_finds1:=prevRLlen[fInds[1]];
   DSF1:=DataSoFar[1][op(fInds)];
   for iInd to nops(currRLlen) do
    if currRLexc[iInd]<prevRLlen_finds1 then
     newDimn:=(2^(currRLlen[iInd])  )*DSF1
             +((2^(currRLlen[iInd]))-1)*(prevRLlen_finds1+1)
             -currRLlen[iInd]-currRLdim[iInd];
     if newDimn<=calcToDimension then
      outTable[iInd,op(fInds)]:=newDimn;
      if pInitLoc="finished" then
       pInitLoc:=[iInd,op(fInds)]; 
      else
       pTable[op(pLastLoc)]:=[iInd,op(fInds)];
      fi;
      pLastLoc:=[iInd,op(fInds)];
     fi;
    fi;
   od;
   fInds:=DataSoFar[2][op(fInds)];
  od;
 else
  lengthToGo:=nops_RL-DSFsize;
  timed_message("computing last ",lengthToGo," dimensions all at once");
  outTable:=rtable(seq(1..2,abcdef=1..lengthToGo),
                  rtable_dims(DataSoFar[1]),storage=sparse);
  pTable:=rtable(rtable_dims(outTable),storage=sparse);  
  while fInds<>"finished" do
   prevLength:=prevRLlen[fInds[1]];
   currDim:=DataSoFar[1][op(fInds)];
   iInds:=[seq(1,abcde=1..lengthToGo)];
   outTable[op(iInds),op(fInds)]:=currDim;
   if pInitLoc="finished" then
    pInitLoc:=[op(iInds),op(fInds)]; 
   else
    pTable[op(pLastLoc)]:=[op(iInds),op(fInds)];
   fi;
   pLastLoc:=[op(iInds),op(fInds)];
   for DEPTH from DSFsize+1 to nops_RL while prevLength>0 do
    currDim:=2*currDim+prevLength;
    prevLength=1;
    iInds[-DEPTH+DSFsize]:=2;
    if currDim<=calcToDimension then
     outTable[op(iInds),op(fInds)]:=currDim;
     if pInitLoc="finished" then
      pInitLoc:=[op(iInds),op(fInds)]; 
     else
      pTable[op(pLastLoc)]:=[op(iInds),op(fInds)];
     fi;
     pLastLoc:=[op(iInds),op(fInds)];
    else
     prevLength=0;
    fi;
   od;
   fInds:=DataSoFar[2][op(fInds)];
  od;
 fi;
 pTable[op(pLastLoc)]:="finished";
 if rtable_num_dims(outTable)<nops_RL then
  timed_message("computed ",rtable_num_dims(outTable)," out of ",nops_RL," dimensions deep");
 fi;
 return build_StatMat_TravIns([outTable,pTable,pInitLoc]);
end proc:

strip_subroot_classes_from_TravIns:=proc()
 global StatMat,TravIns,LowestDimension,Root;
 local T;
 if nops(Root)<2 then return NULL; fi;
 T:=TravIns[2];
 while T<>"finished" and T[-1]=1 do
  TravIns[2]:=TravIns[1][op(T)];
  T:=TravIns[2];
 od;
 while T<>"finished" do
  if TravIns[1][op(T)]<>"finished" and TravIns[1][op(T)][-1]=1 then
   TravIns[1][op(T)]:=TravIns[1][op(TravIns[1][op(T)])]:
  else
   T:=TravIns[1][op(T)];
  fi;
 od:
 return NULL;
end proc:

double_class:=proc(inds)
 global StatMat,calcToDimension;
 if StatMat[op(inds)][1]<>0 then
  StatMat[op(inds)][1]:=2*StatMat[op(inds)][1];
  if StatMat[op(inds)][1]*StatMat[op(inds)][2]>calcToDimension then
   StatMat[op(inds)]:=0;
  fi;
 else
  error "this class is dead";
 fi;
 return NULL;
end proc:

kill_class:=proc(inds)
 global StatMat;
 if StatMat[op(inds)][1]<>0 then
  StatMat[op(inds)]:=0;
 else
  error "this class is already dead";
 fi;
 return NULL;
end proc:

rectify_TravIns_find_LD:=proc()
 global StatMat,TravIns,LowestDimension;
 local T;
 LowestDimension:=2^31-1;
 T:=TravIns[2];
 while T<>"finished" and StatMat[op(T)]=0 do
  TravIns[2]:=TravIns[1][op(T)];
  T:=TravIns[2];
 od;
 while T<>"finished" do
  LowestDimension:=min(LowestDimension,StatMat[op(T)][1]*StatMat[op(T)][2]);
  if TravIns[1][op(T)]<>"finished" and StatMat[op(TravIns[1][op(T)])]=0 then
   TravIns[1][op(T)]:=TravIns[1][op(TravIns[1][op(T)])]:
  else
   T:=TravIns[1][op(T)];
  fi;
 od:
 return NULL;
end proc:

pretty_print_power_of_sequence:=proc(KE,pow)
 global Root;
 local ANS,i;
 ANS:='e^pow':
 if Root<>[] and KE[-1]=Root[2..-1] then
  ANS:='srt^pow':
 fi;
 for i from nops(KE) to 1 by -1 do 
  if nops(KE[i])>0 then 
   ANS:=[delta,SQa,SQb,SQc,SQd,SQe,SQf,SQg,SQh,SQi,SQj,SQk][1+nops(KE)-i][op(KE[i])]*ANS;
  fi;
 od;
 ANS; 
end proc:

rectify_and_find_LD_and_strip_low_dim_subroot_classes_from_TravIns:=proc()
 global StatMat,TravIns,LowestDimension,Root;
 local T;
 rectify_TravIns_find_LD_ignoring_subroot();
 if nops(Root)<2 then error "this is all a bit confusing"; fi;
 T:=TravIns[2];
 while T<>"finished" and T[-1]=1 and StatMat[op(T)][2]<LowestDimension-1 do
  TravIns[2]:=TravIns[1][op(T)];
  T:=TravIns[2];
 od;
 while T<>"finished" do
  if TravIns[1][op(T)]<>"finished" and TravIns[1][op(T)][-1]=1 and StatMat[op(TravIns[1][op(T)])][2]<LowestDimension-1 then
   TravIns[1][op(T)]:=TravIns[1][op(TravIns[1][op(T)])]:
  else
   T:=TravIns[1][op(T)];
  fi;
 od:
 return NULL;
end proc:

rectify_TravIns_find_LD_ignoring_subroot:=proc()
 global StatMat,TravIns,LowestDimension;
 local T;
 LowestDimension:=2^31-1;
 T:=TravIns[2];
 while T<>"finished" and StatMat[op(T)]=0 do
  TravIns[2]:=TravIns[1][op(T)];
  T:=TravIns[2];
 od;
 while T<>"finished" do
  if T[-1]<>1 then
   LowestDimension:=min(LowestDimension,StatMat[op(T)][1]*StatMat[op(T)][2]);
  fi;
  if TravIns[1][op(T)]<>"finished" and StatMat[op(TravIns[1][op(T)])]=0 then
   TravIns[1][op(T)]:=TravIns[1][op(TravIns[1][op(T)])]:
  else
   T:=TravIns[1][op(T)];
  fi;
 od:
 return NULL;
end proc:

assign_OM:=proc(numDimsToPrint:=2)
 #automatically runs rectify_TravIns_find_LD beforehand
 global StatMat,TravIns,LowestDimension,OM,calcToDimension,diffCounter,Root;
 local T,L,i,dimOfInterest;
 if Root=[] then
  rectify_TravIns_find_LD();
 else
  rectify_and_find_LD_and_strip_low_dim_subroot_classes_from_TravIns();
 fi;
 L:=[];
 T:=TravIns[2];
 if LowestDimension<calcToDimension then
  while T<>"finished" do
   dimOfInterest:=StatMat[op(T)][1]*StatMat[op(T)][2];
   if (dimOfInterest <= LowestDimension+numDimsToPrint-1 and T[-1]<>1) 
   or  dimOfInterest = LowestDimension-1 then
    L:=[op(L),T];
   fi;
   T:=TravIns[1][op(T)];
  od;
 fi;
 #L:=map(x->[x,remove(y->y=[],[seq(RL[i][x[i]],i=1..nops(x))]),op(StatMat[op(x)])],L);
 L:=map(x->[x,remove(y->y=[],[seq(RL[i][x[i]],i=1..nops(x))]),op(StatMat[op(x)]),StatMat[op(x)][1]*StatMat[op(x)][2],
            2^(add(nops(RL[i][x[i]]),i=1..nops(x)-1))*
            StatMat[op(x)][1]*(dValue+1+nops(RL[-1][x[-1]])
            +add(RL[-1][x[-1]][j]*(2^j-1),j=1..nops(RL[-1][x[-1]])))-1   ],L);
 #[1=location,2=printout,3=power,4=dimensionOfFirstPower,5=t-s,6=t]
 L:=map(x->[op(x),x[6]-x[5],pretty_print_power_of_sequence(x[2],x[3])   ,   E2DegreePRHomEltNoZero(unExcessFormatPR([[x[3],x[2]]]),dValue)],L);
 #[...,7=s,8=prettyprint,9=allE2dimensions(forDebug)]
 L:=sort(L,(x,y)->(x[5]<y[5] or 
                           (x[5]=y[5] and x[6]<y[6])) or
                           (x[5]=y[5] and x[6]=y[6] and
  lexorder(StringTools[Reverse](convert(ListTools[Flatten](x[2]),string)),
           StringTools[Reverse](convert(ListTools[Flatten](y[2]),string)))
                            )):
 for i to nops(L) do
  L[i]:=[op(L[i]),i];
 od;
 L:=[['loc',`elt`,`pow`,`1powDim`,`t-s`,`t`,`s`,`elt`,`dims`,` `],op(L)];
 OM:=Matrix(L);
 if nops(L)>1 then
  timed_message("after ",diffCounter," differentials, OM has ",nops(L)-1," entries, starting in dimension ",LowestDimension);
 else
  timed_message("after ",diffCounter," differentials, we've cleared up to dimension ",calcToDimension);
 fi;
 if LowestDimension>=calcToDimension then 
  timed_message("------------------------------------final dimension!------------------------------------"); 
 fi;
 return NULL;
end proc:

print_OM:=proc(outputVector:=[10,8,7,5])
 global OM;
 #set the following 2 to 1 to show headings
 print(LinearAlgebra[SubMatrix](OM,[2..-1],outputVector));
 return NULL;
end proc:

assign_and_print_OM:=proc(numDimsToPrint:=2,outputVector:=[10,8,7,5])
 assign_OM(numDimsToPrint);
 print_OM(outputVector);
 return NULL;
end proc:

diff_extractor:=proc(TR,SR,outputVector:=[10,8,7,5])
 global OM;
 print(LinearAlgebra[SubMatrix](OM,[TR+1,SR+1],outputVector));
 #why not test somthing at this point?
 [`?`,cat("d",OM[TR+1,7]-OM[SR+1,7]),OM[SR+1,2],OM[SR+1,3],OM[TR+1,2],OM[TR+1,3],OM[SR+1,1],OM[TR+1,1]];
end proc:

apply_stored_diffs_and_assign_and_print_OM:=proc(numDimsToPrint:=2,outputVector:=[10,8,7,5])
 global ManuallyStoredDiffs;
 local i;
 ensure_dlog_open();
 if assigned(ManuallyStoredDiffs) then
  for i in ManuallyStoredDiffs do
   IM(i);
  od;
 fi;
 ManuallyStoredDiffs:=[];
 assign_and_print_OM(numDimsToPrint,outputVector);
 return NULL;
end proc:

quick_extract_and_store_diffs:=proc()
 local i,Listo;
 global ManuallyStoredDiffs,diffCounter;
 Listo:=[args];
 timed_message("after ",diffCounter," differentials, storing ",nops(Listo)," differentials:");
 for i to nops(Listo) do
  Listo[i]:=diff_extractor(Listo[i][1],Listo[i][2]);
  if Listo[i][3][-1][2..-1]<>Listo[i][5][-1] then error "I think this last one was wrong" fi;
 od;
 ManuallyStoredDiffs:=Listo;
 return NULL;
end proc:

quick_extract_and_store_initial_diff_string:=proc(len,sourceStarts:="no gap")
 quick_extract_and_store_diffs(seq([i+1,i+`if`(sourceStarts="no gap" or sourceStarts=0,len+1,sourceStarts)],i=0..len-1));
 return NULL;
end proc:

trim_off_00002_001002_classes:=proc()
 global StatMat, TravIns, dValue, RL, nops_RL, delta_admissables;
 local OneIndices,ell,ZeroList,temp,TempZeroList,OnePos;
 OneIndices:=[seq(1,i = 1 .. nops_RL-1)];
 StatMat[op(OneIndices),1]:=0;
 for ell from 1 to ilog2(calcToDimension) do
  ZeroList:=[seq(0,dummy=1..ell-1),2];
  temp:=ListTools[Search](ZeroList,delta_admissables);
  if temp>0 then StatMat[op(OneIndices),temp]:=0; fi;
  for OnePos from 2 to ell do
   TempZeroList:=ZeroList;
   TempZeroList[-OnePos]:=1;
   temp:=ListTools[Search](TempZeroList,delta_admissables);
   if temp>0 then StatMat[op(OneIndices),temp]:=0; fi;
  od;
 od;
 timed_message("trimmed off the 00002 and 001002 classes");
 return NULL;
end proc:

implement_diff:=proc(difl)
 global RL,StatMat,diffCounter;
 if nops(StatMat[op(difl[7])])<>2 or nops(StatMat[op(difl[8])])<>2 then
  error "either source or target is already dead or broken";
 fi;
 if difl[4]<>StatMat[op(difl[7])][1] then
  error "the source power is wrong";
 fi;
 if difl[6]<>StatMat[op(difl[8])][1] then
  error "the target power is likely to be wrong";
 fi;
 kill_class(difl[8]);
 double_class(difl[7]);
 diffCounter:=diffCounter+1;
 if outputStreamOpenFlag=0 then
  reopen_dlog();
 elif outputStreamOpenFlag<>1 then
  new_dlog();
 fi;
 dlog(difl);
 return NULL;
end proc:

implement_diff_if_in_range_TF:=proc(difl)
 #implements a differential if it's in range, returning true/false
 global RL,StatMat;
 if difl=0 or StatMat[op(difl[7])]=0 or StatMat[op(difl[8])]=0 then
  return false;
 fi;
 implement_diff(difl);
 return true;
end proc:

implement_diff_if_in_range_TF_with_some_squares:=proc(difl,numSquares:=2^31-1)
 local counter,diff;
 counter:=0;diff:=difl;
 while counter<=numSquares and implement_diff_if_in_range_TF(diff) do
  if counter<numSquares then
   diff:=differential_squarer(diff);
  fi;
  counter:=counter+1;
 od;
 return evalb(counter<>0);
end proc:

differential_coords_finder_ints_guaranteed:=proc(diff,sEqualityPositions,tEqualityPositions)
 #last two entries can be integers which state 
 #how many of the final entries of...
 #...diff[7] and diff[8] are correct.
 local t1,t2;
 t1:=find_RL_coordinates_with_consecutive_hints(diff[3],diff[7][-sEqualityPositions..-1]);
 if t1=0 then return 0; fi;
 t2:=find_RL_coordinates_with_consecutive_hints(diff[5],diff[8][-tEqualityPositions..-1]);
 if t2=0 then return 0; fi;
 return [seq(diff[abc],abc=1..6),t1,t2];
end proc:

double_rMinusOne:=proc(dwhat)
 option remember;
 local SR;
 SR:=StringTools[SelectRemove]( StringTools[IsDigit],  dwhat  );
 if SR[2]<>"d" or dwhat[1]<>"d" then error "not of form d123" fi;
 SR[1];
 cat("d",2*parse(%)-1);
end proc:

double_rMinusOne_repeat:=proc(dwhat,number)
 option remember;
 if number=0 then return dwhat;
 elif number<0 then error "need a nonnegative number of iterations";
 else return double_rMinusOne_repeat(double_rMinusOne(dwhat),number-1);
 fi;
end proc:

all_ordered_partitions_with_sum_at_most:=proc(mAx) option remember;
 return [seq(seq(op(combinat[composition](n,i)),i=1..n),n=1..mAx)];
end proc:

UP:=proc(diff,sDescriptor,sData,tDescriptor,tData)
 #changes a differential in one of 2*2 simple ways:
 #2. "add"="add new sequence to left"
 #3. "app"="append to left of leftmost nontrivial sequence"
 local output,sHint,tHint;
 if diff=0 then return 0 fi;
 output:=diff;
 output[3]:=remove(x->x=[],output[3]);
 output[5]:=remove(x->x=[],output[5]);
 #if sDescriptor="square" then
 # output[4]:=2*output[4];
 # sHint:="done";
 if sDescriptor="add" then
  sHint:=nops(output[3]);
  output[3]:=[sData,op(output[3])];
 #elif sDescriptor="add top 1-element sequence to left" then
 # sHint:=nops(output[3]);
 # output[3]:=[[nops(output[3][1])-1],op(output[3])];
 elif sDescriptor="app" then
  sHint:=nops(output[3])-1;
  output[3][1]:=[op(sData),op(output[3][1])];
 #elif sDescriptor="completely replace, (k+...+ell2)+=1, inputting [S,pow]" then
 # output[3]:=sData[1];output[4]:=sData[2];
 # sHint:="no hints";
 else
  error "I don't recognise the command";
 fi;
 #if tDescriptor="square" then (out of fashion)
 # output[6]:=2*output[6];
 # tHint:="done";
 if tDescriptor="add" then
  tHint:=nops(output[5]);
  output[5]:=[tData,op(output[5])];
 #elif tDescriptor="add top 1-element sequence to left" then
 # tHint:=nops(output[5]);
 # output[5]:=[[nops(output[5][1])-1],op(output[5])];
 elif tDescriptor="app" then
  tHint:=nops(output[5])-1;
  output[5][1]:=[op(tData),op(output[5][1])];
 #elif tDescriptor="completely replace, (k+...+ell2)+=1, inputting [S,pow]" then
 # output[5]:=tData[1];output[6]:=tData[2];
 # tHint:="no hints";
 else
  error "I don't recognise the command";
 fi;
 output[2]:=double_rMinusOne_repeat(output[2],nops(sData));
 return differential_coords_finder_ints_guaranteed(output,sHint,tHint);
end proc:

#differential_squarer:=proc(diff)
# return UP(diff,"square","meh","add top 1-element sequence to left","meh");
#end proc:

string_of_length_one_sequences_for_squares_index_finder:=proc(N_so_far,most_recent_length) option remember;
 #helps speed up the process of adding in the squares of a differential
 global RL,nops_RL;
 local ans,mrl,search_loc;
 ans:=[]; mrl:=most_recent_length;
 while nops(ans)+N_so_far<nops_RL and mrl<>0 do
  search_loc:=RLlookup(-N_so_far-nops(ans)-1,mrl-1);
  if type(search_loc,'integer') then
   ans:=[search_loc,op(ans)];
   mrl:=1;
  else
   mrl:=0;
  fi;
 od;
 return ans;
end proc:

num_of_squarings_calculator:=proc(SM82) option remember;
 global calcToDimension;
 return ilog2( (1+calcToDimension)/(1+SM82) );
end proc:

IM:=proc(difl)
 global StatMat,calcToDimension,diffCounter,nops_RL;
 local counter,diff,dim,num_of_squarings,SM7,SM8,trimmedTargIndex,prefixes;
 if difl=0 then return false; fi;
 if difl[4]<>1 or difl[6]<>1 then error "I expected only first power to first power"; fi; 
 SM7:=StatMat[op(difl[7])]; SM8:=StatMat[op(difl[8])];
 if SM7=0 then return false; fi;
 if SM8=0 or SM7[1]<>1 or SM8[1]<>1 then error "this class has already been messed with"; fi;
 if SM7[2]<>SM8[2]+1 then error "dimensions don't differ by 1"; fi;
 num_of_squarings:=num_of_squarings_calculator(SM8[2]);
 trimmedTargIndex:=[op(remove(x->x=1,difl[8][1..-2])),difl[8][-1]];
 prefixes:=string_of_length_one_sequences_for_squares_index_finder(nops(trimmedTargIndex),
            nops(RL[-nops(trimmedTargIndex)][trimmedTargIndex[1]]))[-num_of_squarings..-1];
 dlog(difl); diffCounter:=diffCounter+1;
 StatMat[op(difl[7])]:=0;
 for counter from 0 to nops(prefixes) do
  StatMat[seq(1,hhh=counter+nops(trimmedTargIndex)+1..nops_RL),op(prefixes[-counter..-1]),op(trimmedTargIndex)]:=0;
 od;
 return true;
end proc:

first_round_of_differentials:=proc()
 #slower than the previous version, but easier to read and emulate!
 global RL,StatMat,dValue,outputStreamOpenFlag,diffCounter,predecessor_data,delta_admissables;
 local ell1,exc1,a,i,srcI1,trgS,diff,srcCoords,trgCoords,diffCounterStarting,tnLP,cdLP,
       predecessor_data_of_i;
 timed_message("starting first round of differentials");
 ensure_dlog_open();
 diffCounterStarting:=diffCounter;
 tnLP:=nops(delta_admissables);
 cdLP:=tnLP:
 for i from 2 to tnLP do
  if cdLP>1 and (i-2)*cdLP>=tnLP then
   timed_message((1/cdLP," done"));
   cdLP:=`if`(cdLP>5,iquo(cdLP,2),cdLP/2);
   save_dlog("quiet");
  fi:
  srcI1:=delta_admissables[i];
  predecessor_data_of_i:=predecessor_data[i];
  a:=remove(x->x=0,srcI1);
  if a<>[1,dValue] and a<>[dValue] then
   ell1:=nops(srcI1);
   exc1:=add(srcI1[gh],gh=1..ell1);
   a:=dValue+ell1-exc1;
   if a<ell1-1 and a>=1 then
    trgS:=[[a],srcI1[2..-1]];
   else
    error "this is strange";
   fi;
   diff:=[`rnd1`,cat("d",a),[srcI1],1,trgS,1,[i],[predecessor_data_of_i]];
   diff:=differential_coords_finder_ints_guaranteed(diff,1,1);
   IM(diff);
  fi;
 od;
 timed_message("finished first round of differentials - there were ",diffCounter-diffCounterStarting);
 return NULL;
end proc:

second_round_of_differentials:=proc()
 global RL,StatMat,dValue,outputSreamOpenFlag,diffCounter,predecessor_data,delta_admissables;
 local ell1,exc1,jay,i,srcI1,srcS,trgS,srcPow,trgPow,`initdiff`,diffCounterStarting,tnLP,cdLP,
       `diff`,`diff0_0`,`diff1_1`,`diff0.0_10`,`diff0.0.0_0.10`,`diff0.0.0.0_10.10`,`diff0.0.0.0.0_0.10.10`,
       xtra,`xtradiff`,`xtradiff0_0`,`xtradiff1_1`,`2xtradiff2_2`,`1xtradiff0.1_11`,`1xtradiff0.0_20`,
       `12xtradiff10_10`,`1xtradiff0.0.0_0.20`,`1xtradiff0.0.1_0.11`,`diff0.0.0.0.0.0_10.10.10`,
       predecessor_data_of_i;
 timed_message("starting second round of differentials");
 ensure_dlog_open();
 diffCounterStarting:=diffCounter;
 tnLP:=nops(delta_admissables);
 cdLP:=tnLP:
 for i from 2 to tnLP do
  if cdLP>1 and (i-2)*cdLP>=tnLP then
   timed_message((1/cdLP," done"));
   cdLP:=`if`(cdLP>5,iquo(cdLP,2),cdLP/2);
   save_dlog("quiet");
  fi:
  srcI1:=delta_admissables[i];
  predecessor_data_of_i:=predecessor_data[i];
  ell1:=nops(srcI1);
  exc1:=add(srcI1[gh],gh=1..ell1); 
  for jay from 2+dValue+ell1-exc1 to ell1-1 do
   srcS:=[[jay],srcI1];
   trgS:=[[jay-1-(dValue+ell1-exc1),dValue+ell1-exc1],srcI1[2..-1]];
   `initdiff`:=differential_coords_finder_ints_guaranteed([`rnd2`,cat("d",2*(dValue+ell1-exc1-1)+1),
                     srcS,1,trgS,1,[i],[predecessor_data_of_i]],1,1);
  #`initdiff`=[[j],[xyz]]->[[j-1-a,a],[yz]]
   if IM(`initdiff`) then   
    `diff0_0`:=UP(`initdiff`,"add",[0],"add",[0]);
   #`diff0_0`=[[0],[j],[xyz]]->[[0],[j-1-a,a],[yz]]
    if IM(`diff0_0`) then
     `diff0.0_10`:=UP(`diff0_0`,"add",[0],"app",[1]);
    #`diff0.0_10`=[[0],[0],[j],[xyz]]->[[1,0],[j-1-a,a],[yz]]
     if IM(`diff0.0_10`) then
      `diff0.0.0_0.10`:=UP(`diff0.0_10`,"add",[0],"add",[0]);
     #`diff0.0.0_0.10`=[[0],[0],[0],[j],[xyz]]->[[0],[1,0],[j-1-a,a],[yz]]
      if IM(`diff0.0.0_0.10`) then
       `diff0.0.0.0_10.10`:=UP(`diff0.0.0_0.10`,"add",[0],"app",[1]);
      #`diff0.0.0.0_10.10`=[[0],[0],[0],[0],[j],[xyz]]->[[1,0],[1,0],[j-1-a,a],[yz]]
       if IM(`diff0.0.0.0_10.10`) then
        `diff0.0.0.0.0_0.10.10`:=UP(`diff0.0.0.0_10.10`,"add",[0],"add",[0]);
       #`diff0.0.0.0.0_0.10.10`=[[0],[0],[0],[0],[0],[j],[xyz]]->[[0],[1,0],[1,0],[j-1-a,a],[yz]]
        if IM(`diff0.0.0.0.0_0.10.10`) then
         `diff0.0.0.0.0.0_10.10.10`:=UP(`diff0.0.0.0.0_0.10.10`,"add",[0],"app",[1]);
        #`diff0.0.0.0.0.0_10.10.10`=[[0],[0],[0],[0],[0],[0],[j],[xyz]]->[[1,0],[1,0],[1,0],[j-1-a,a],[yz]]
         if IM(`diff0.0.0.0.0.0_10.10.10`) then
          `diff0.0.0.0.0.0.0_0.10.10.10`:=UP(`diff0.0.0.0.0.0_10.10.10`,"add",[0],"add",[0]);
          IM(`diff0.0.0.0.0.0.0_0.10.10.10`);
         fi;
        fi;
       fi;
      fi;
     fi;
    fi;
    for xtra in all_ordered_partitions_with_sum_at_most(ell1-jay-1) do
     `xtradiff`:=UP(`initdiff`,"app",xtra,"app",xtra);
    #`xtradiff`=[[tuv,j],[xyz]]->[[tuv,j-1-a,a],[yz]]
     if IM(`xtradiff`) then
      `xtradiff0_0`:=UP(`xtradiff`,"add",[0],"add",[0]);
     #`xtradiff0_0`=[[0],[tuv,j],[xyz]]->[[0],[tuv,j-1-a,a],[yz]]
      xd00flag:=IM(`xtradiff0_0`);
      `xtradiff1_1`:=UP(`xtradiff`,"add",[1],"add",[1]);
     #`xtradiff1_1`=[[1],[tuv,j],[xyz]]->[[1],[tuv,j-1-a,a],[yz]]
      xd11flag:=IM(`xtradiff1_1`);
      if nops(xtra)=3 then
       `4xtradiff2_2`:=UP(`xtradiff`,"add",[2],"add",[2]);
       IM(`4xtradiff2_2`);
       `4xtradiff3_3`:=UP(`xtradiff`,"add",[3],"add",[3]);
       IM(`4xtradiff2_2`);
       `4xtradiff4_4`:=UP(`xtradiff`,"add",[4],"add",[4]);
       IM(`4xtradiff2_2`);
      fi;
      if nops(xtra)=3 then
       `3xtradiff2_2`:=UP(`xtradiff`,"add",[2],"add",[2]);
      #`3xtradiff2_2`=[[2],[t,u,v,j],[xyz]]->[[2],[t,u,v,j-1-a,a],[yz]]
       if IM(`3xtradiff2_2`) then
        `3xtradiff12_12`:=UP(`3xtradiff2_2`,"app",[1],"app",[1]);
        if IM(`3xtradiff12_12`) then
         `3xtradiff0.12_112`:=UP(`3xtradiff12_12`,"add",[0],"app",[1]);
         IM(`3xtradiff0.12_112`);
         `3xtradiff1.12_0.12`:=UP(`3xtradiff12_12`,"add",[1],"add",[0]);
         IM(`3xtradiff1.12_0.12`);
        fi;
        `3xtradiff0.2_22`:=UP(`3xtradiff2_2`,"add",[0],"app",[2]);
        if IM(`3xtradiff0.2_22`) then
         `3xtradiff0.0.2_0.22`:=UP(`3xtradiff0.2_22`,"add",[0],"add",[0]);
         IM(`3xtradiff0.0.2_0.22`);
        fi;
       fi;
       `3xtradiff3_3`:=UP(`xtradiff`,"add",[3],"add",[3]);
      #`3xtradiff3_3`=[[3],[t,u,v,j],[xyz]]->[[3],[t,u,v,j-1-a,a],[yz]]
       if IM(`3xtradiff3_3`) then
        `3xtradiff0.3_13`:=UP(`3xtradiff3_3`,"add",[0],"app",[1]);
        if IM(`3xtradiff0.3_13`) then
         `3xtradiff0.0.3_0.13`:=UP(`3xtradiff0.3_13`,"add",[0],"add",[0]);
         IM(`3xtradiff0.0.3_0.13`);
        fi;
       fi;
       if xd11flag then
        `3xtradiff11_11`:=UP(`xtradiff1_1`,"app",[1],"app",[1]);
        if IM(`3xtradiff11_11`) then
         `3xtradiff111_111`:=UP(`3xtradiff11_11`,"app",[1],"app",[1]);
         IM(`3xtradiff111_111`);
         `3xtradiff0.11_211`:=UP(`3xtradiff11_11`,"add",[0],"app",[2]);
         IM(`3xtradiff0.11_211`);
         `3xtradiff1.11_0.11`:=UP(`3xtradiff11_11`,"add",[1],"add",[0]);
         IM(`3xtradiff1.11_0.11`);
        fi;
        `3xtradiff21_21`:=UP(`xtradiff1_1`,"app",[2],"app",[2]);
        if IM(`3xtradiff21_21`) then
         `3xtradiff0.21_121`:=UP(`3xtradiff21_21`,"add",[0],"app",[1]);
         IM(`3xtradiff0.21_121`);
         `3xtradiff1.21_0.21`:=UP(`3xtradiff21_21`,"add",[1],"add",[0]);
         IM(`3xtradiff1.21_0.21`);
        fi;
        `3xtradiff0.1_31`:=UP(`xtradiff1_1`,"add",[0],"app",[3]);
        if IM(`3xtradiff0.1_31`) then
         `3xtradiff0.0.1_0.31`:=UP(`3xtradiff0.1_31`,"add",[0],"add",[0]);
         IM(`3xtradiff0.0.1_0.31`);
        fi;
       fi;
       if xd00flag then
        `3xtradiff0.0_40`:=UP(`xtradiff0_0`,"add",[0],"app",[4]);
        if IM(`3xtradiff0.0_40`) then
         `3xtradiff0.0.0_0.40`:=UP(`3xtradiff0.0_40`,"add",[0],"add",[0]);
         IM(`3xtradiff0.0.0_0.40`);
        fi;
        `3xtradiff30_30`:=UP(`xtradiff0_0`,"app",[3],"app",[3]);
        if IM(`3xtradiff30_30`) then
         `3xtradiff0.30_130`:=UP(`3xtradiff30_30`,"add",[0],"app",[1]);
         IM(`3xtradiff0.30_130`);
         `3xtradiff1.30_0.30`:=UP(`3xtradiff30_30`,"add",[1],"add",[0]);
         IM(`3xtradiff1.30_0.30`);
        fi;
        `3xtradiff20_20`:=UP(`xtradiff0_0`,"app",[2],"app",[2]);
        if IM(`3xtradiff20_20`) then
         `3xtradiff120_120`:=UP(`3xtradiff20_20`,"app",[1],"app",[1]);
         IM(`3xtradiff120_120`);
         `3xtradiff0.20_220`:=UP(`3xtradiff20_20`,"add",[0],"app",[2]);
         IM(`3xtradiff0.20_220`);
         `3xtradiff1.20_0.20`:=UP(`3xtradiff20_20`,"add",[1],"add",[0]);
         IM(`3xtradiff1.20_0.20`);
        fi;
        `3xtradiff10_10`:=UP(`xtradiff0_0`,"app",[1],"app",[1]);
        if IM(`3xtradiff10_10`) then
         `3xtradiff110_110`:=UP(`3xtradiff10_10`,"app",[1],"app",[1]);
         if IM(`3xtradiff110_110`) then
          `3xtradiff1110_1110`:=UP(`3xtradiff110_110`,"app",[1],"app",[1]);
          IM(`3xtradiff1110_1110`);
         fi;
         `3xtradiff210_210`:=UP(`3xtradiff10_10`,"app",[2],"app",[2]);
         IM(`3xtradiff210_210`);
         `3xtradiff0.10_310`:=UP(`3xtradiff10_10`,"add",[0],"app",[3]);
         IM(`3xtradiff0.10_310`);
         `3xtradiff1.10_0.10`:=UP(`3xtradiff10_10`,"add",[1],"add",[0]);
         IM(`3xtradiff1.10_0.10`);
        fi;
       fi;
      fi;
      if nops(xtra)=2 then
       `2xtradiff2_2`:=UP(`xtradiff`,"add",[2],"add",[2]);
      #`2xtradiff2_2`=[[2],[u,v,j],[xyz]]->[[2],[u,v,j-1-a,a],[yz]]
       if IM(`2xtradiff2_2`) then
        `2xtradiff0.2_12`:=UP(`2xtradiff2_2`,"add",[0],"app",[1]);
        if IM(`2xtradiff0.2_12`) then
         `2xtradiff0.0.2_0.12`:=UP(`2xtradiff0.2_12`,"add",[0],"add",[0]);
         IM(`2xtradiff0.0.2_0.12`);
        fi;
       fi;
       if xd11flag then
        `2xtradiff0.1_21`:=UP(`xtradiff1_1`,"add",[0],"app",[2]);
        if IM(`2xtradiff0.1_21`) then
         `2xtradiff0.0.1_0.21`:=UP(`2xtradiff0.1_21`,"add",[0],"add",[0]);
         IM(`2xtradiff0.0.1_0.21`);
        fi;
       fi;
       if xd00flag then
        `2xtradiff0.0_30`:=UP(`xtradiff0_0`,"add",[0],"app",[3]);
        if IM(`2xtradiff0.0_30`) then
         `2xtradiff0.0.0_0.30`:=UP(`2xtradiff0.0_30`,"add",[0],"add",[0]);
         IM(`2xtradiff0.0.0_0.30`);
        fi;
        `2xtradiff110_110`:=UP(`xtradiff0_0`,"app",[11],"app",[11]);
        if IM(`2xtradiff110_110`) then
         `2xtradiff0.110_1110`:=UP(`2xtradiff110_110`,"add",[0],"app",[1]);
         IM(`2xtradiff0.110_1110`);
         `2xtradiff1.110_0.110`:=UP(`2xtradiff110_110`,"add",[1],"add",[0]);
         IM(`2xtradiff1.110_0.110`);
         `2xtradiff2.110_1.110`:=UP(`2xtradiff110_110`,"add",[2],"add",[1]);
         IM(`2xtradiff2.110_1.110`);
        fi;
       fi;
      fi;
      if nops(xtra)=1 then
       if xd11flag then
        `1xtradiff0.1_11`:=UP(`xtradiff1_1`,"add",[0],"app",[1]);
       #`1xtradiff0.1_11`=[[0],[1],[v,j],[xyz]]->[[1,1],[v,j-1-a,a],[yz]]
        if IM(`1xtradiff0.1_11`) then
         `1xtradiff0.0.1_0.11`:=UP(`1xtradiff0.1_11`,"add",[0],"add",[0]);
        #`1xtradiff0.0.1_0.11`=[[0],[0],[1],[v,j],[xyz]]->[[0],[1,1],[v,j-1-a,a],[yz]]
         if IM(`1xtradiff0.0.1_0.11`) then
          `1xtradiff0.0.0.1_10.11`:=UP(`1xtradiff0.0.1_0.11`,"add",[0],"app",[1]);
          if IM(`1xtradiff0.0.0.1_10.11`) then
           `1xtradiff0.0.0.0.1_0.10.11`:=UP(`1xtradiff0.0.0.1_10.11`,"add",[0],"add",[0]);
           IM(`1xtradiff0.0.0.0.1_0.10.11`);
          fi;
         fi;
        fi;
       fi;
       if xd00flag then
        `1xtradiff0.0_20`:=UP(`xtradiff0_0`,"add",[0],"app",[2]);
       #`1xtradiff0.0_20`=[[0],[0],[v,j],[xyz]]->[[2,0],[v,j-1-a,a],[yz]]
        if IM(`1xtradiff0.0_20`) then
         `1xtradiff0.0.0_0.20`:=UP(`1xtradiff0.0_20`,"add",[0],"add",[0]);
        #`1xtradiff0.0.0_0.20`=[[0],[0],[0],[v,j],[xyz]]->[[0],[2,0],[v,j-1-a,a],[yz]]
         if IM(`1xtradiff0.0.0_0.20`) then
          `1xtradiff0.0.0.0_10.20`:=UP(`1xtradiff0.0.0_0.20`,"add",[0],"app",[1]);
          if IM(`1xtradiff0.0.0.0_10.20`) then
           `1xtradiff0.0.0.0.0_0.10.20`:=UP(`1xtradiff0.0.0.0_10.20`,"add",[0],"add",[0]);
           IM(`1xtradiff0.0.0.0.0_0.10.20`);
          fi;
         fi;
        fi;
       fi;
      fi;
      if xd00flag and (nops(xtra)=1 or nops(xtra)=2) then
       `12xtradiff10_10`:=UP(`xtradiff0_0`,"app",[1],"app",[1]);
      #`12xtradiff10_10`=[[1,0],[v,j],[xyz]]->[[1,0],[v,j-1-a,a],[yz]]
       if IM(`12xtradiff10_10`) then
        if nops(xtra)=1 then
         `1xtradiff0.10_110`:=UP(`12xtradiff10_10`,"add",[0],"app",[1]);
         `1xtradiff1.10_0.10`:=UP(`12xtradiff10_10`,"add",[1],"add",[0]);
         if IM(`1xtradiff1.10_0.10`) then
          `1xtradiff0.1.10_10.10`:=UP(`1xtradiff1.10_0.10`,"add",[0],"app",[1]);
          if IM(`1xtradiff0.1.10_10.10`) then
           `1xtradiff0.0.1.10_0.10.10`:=UP(`1xtradiff0.1.10_10.10`,"add",[0],"add",[0]);
           IM(`1xtradiff0.0.1.10_0.10.10`);
          fi;
         fi;
         if IM(`1xtradiff0.10_110`) then
          `1xtradiff10.10_0.110`:=UP(`1xtradiff0.10_110`,"app",[1],"add",[0]);
          if IM(`1xtradiff10.10_0.110`) then
           `1xtradiff0.10.10_10.110`:=UP(`1xtradiff10.10_0.110`,"add",[0],"app",[1]);
           IM(`1xtradiff0.10.10_10.110`);
           `1xtradiff1.10.10_20.110`:=UP(`1xtradiff10.10_0.110`,"add",[1],"app",[2]);
           IM(`1xtradiff1.10.10_20.110`);
          fi;
          `1xtradiff0.0.10_1.110`:=UP(`1xtradiff0.10_110`,"add",[0],"add",[1]);
          if IM(`1xtradiff0.0.10_1.110`) then
           `1xtradiff0.0.0.10_11.110`:=UP(`1xtradiff0.0.10_1.110`,"add",[0],"app",[1]);
           IM(`1xtradiff0.0.0.10_11.110`);
          fi;
         fi;
        fi;
        if nops(xtra)=2 then
         `2xtradiff0.10_210`:=UP(`12xtradiff10_10`,"add",[0],"app",[2]);
         if IM(`2xtradiff0.10_210`) then
          `2xtradiff10.10_0.210`:=UP(`2xtradiff0.10_210`,"app",[1],"add",[0]);
          IM(`2xtradiff10.10_0.210`);
         fi;
         `2xtradiff1.10_0.10`:=UP(`12xtradiff10_10`,"add",[1],"add",[0]);
         IM(`2xtradiff1.10_0.10`);
         `2xtradiff110_110`:=UP(`12xtradiff10_10`,"app",[1],"app",[1]);
         IM(`2xtradiff110_110`);
        fi;
       fi;
      fi;
      if nops(xtra)=2 then
       `2xtradiff11_11`:=UP(`xtradiff1_1`,"app",[1],"app",[1]);
       if IM(`2xtradiff11_11`) then
        `2xtradiff0.11_111`:=UP(`2xtradiff11_11`,"add",[0],"app",[1]);
        if IM(`2xtradiff0.11_111`) then
         `2xtradiff10.11_0.111`:=UP(`2xtradiff0.11_111`,"app",[1],"add",[0]);
         IM(`2xtradiff10.11_0.111`);
        fi;
        `2xtradiff1.11_0.11`:=UP(`2xtradiff11_11`,"add",[1],"add",[0]);
        IM(`2xtradiff1.11_0.11`);
        `2xtradiff20_20`:=UP(`xtradiff0_0`,"app",[2],"app",[2]);
        if IM(`2xtradiff20_20`) then
         `2xtradiff0.20_120`:=UP(`2xtradiff20_20`,"add",[0],"app",[1]);
         if IM(`2xtradiff0.20_120`) then
          `2xtradiff10.20_0.120`:=UP(`2xtradiff0.20_120`,"app",[1],"add",[0]);
          IM(`2xtradiff10.20_0.120`);
         fi;
         `2xtradiff1.20_0.20`:=UP(`2xtradiff20_20`,"add",[1],"add",[0]);
         IM(`2xtradiff1.20_0.20`);
        fi;
       fi;
      fi;
     fi;
    od;
   fi;
  od;
 od;
 timed_message("finished 2nd round of differentials - there were ",diffCounter-diffCounterStarting);
 return NULL;
end proc:

autowipe:=proc()
 global OM;
 local numberOfInterestingRows,seqOfDims,numberAtBottomDimension,seqOfElements;
 if nargs>0 then
  quick_extract_and_store_diffs(args);
  apply_stored_diffs_and_assign_and_print_OM();
  return NULL;
 fi;
 numberOfInterestingRows:=LinearAlgebra[RowDimension](OM)-1;
 seqOfDims:=[seq(OM[i+1,5],i=1..numberOfInterestingRows)];
 seqOfElements:=[seq(OM[i+1,2],i=1..numberOfInterestingRows)];
 numberAtBottomDimension:=nops(remove(x->x<>seqOfDims[1],seqOfDims));
 if numberOfInterestingRows<2*numberAtBottomDimension or
                 seqOfDims[numberAtBottomDimension+1..2*numberAtBottomDimension]
    <>map(x->x+1,seqOfDims[1..numberAtBottomDimension]) or
      map(x->x[-1][2..-1],seqOfElements[numberAtBottomDimension+1..2*numberAtBottomDimension])
    <>map(x->x[-1],       seqOfElements[1..numberAtBottomDimension]) or
      map(x->nops(x[-1])+nops(x[-2]),seqOfElements[numberAtBottomDimension+1..2*numberAtBottomDimension])
    <>map(x->nops(x[-1])+nops(x[-2]),seqOfElements[1..numberAtBottomDimension]) then
  error "bad idea (no damage done)";
 else
  quick_extract_and_store_initial_diff_string(numberAtBottomDimension);
  apply_stored_diffs_and_assign_and_print_OM();
 fi;
 return NULL;
end proc:





Profile();
########### begin program
set_dimensions_and_Root(100000,2,[1,0,0,2,0,2]);
if FileTools[Exists](savefile_name(SMandTI))=false then
 build_RL_and_RLlookup();
 build_StatMat_TravIns();
 trim_off_00002_001002_classes();
 save RL, nops_RL, predecessor_data, delta_admissables, StatMat, TravIns, diffCounter, RLlookup, savefile_name(SMandTI);
 assign_and_print_OM();
 first_round_of_differentials();
 close_dlog();
 assign_and_print_OM();
 second_round_of_differentials();
 assign_and_print_OM();
 close_dlog();
else
 read savefile_name(SMandTI):
 timed_message("you just loaded the early data");
 assign_and_print_OM();
 first_round_of_differentials();
 close_dlog();
 assign_and_print_OM();
 second_round_of_differentials();
 assign_and_print_OM();
 close_dlog();
fi;

SortBy('number'=20,'order'=time);

quick_extract_and_store_initial_diff_string(1,3);
apply_stored_diffs_and_assign_and_print_OM();
while LowestDimension<calcToDimension do autowipe(); od;


SUGGESTED SPEEDUPS:
return [seq(1,asd = 1 .. nops_RL-nops(S)), op(ans)] and
if not type(RLglance,'integer') then
   from find_RL_coordinates_with_consecutive_hints
trimmedTargIndex := remove(x->x = 1,difl[8]); and
if difl = 0 then
   from IM
output[3] := remove(x ->x = [],output[3]);
output[5] := remove(x ->x = [],output[5]);
   from UP
return [seq(diff[abc],abc = 1 .. 6), t1, t2]
   from differential_coords_finder_ints_guaranteed
trimmedTargIndex:=[op(remove(x->x=1,difl[8][1..-2])),difl[8][-1]]; is inefficient