SqCompsMi:=proc(M,i1min)
  local ans,L;
  ans:=[];
  if M=-1 then return [[]]; fi;
  for L from 1 to M-i1min+1 do
    ans:=[op(ans),
          op( map(xx->xx+[seq(0,dummy=1..L-1),i1min-1],
                  sort([op(combinat[composition](M-(i1min-1), L))],
                       (x,y)->lexorder(convert(x,string),convert(y,string))
                      )
                 ) 
            )];
  od;
  ans;
end proc:
ExcessFormatSingle:=y->`if`(y=[],[], [seq(y[i-1]-2*y[i],i=2..nops(y)),y[-1]]):
UserFeedback:=proc()
 local ans,x;ans:="";
 for x in args do ans:=cat(ans,convert(x,'string'));od;
 writeline(default,ans); return NULL;
end proc:

#new_dlog()
#force_new_dlog()
#close_dlog()
#reopen_dlog()
#ensure_dlog_open()
#save_dlog()
#dlog()
#timed_message()
#timed_dlog()
#
#set_dimensions(cTd,d)
#build_RL_and_RLlookup()
#StatMat_TravIns_starter()
#build_StatMat_TravIns(DataSoFar:="none")
#trim_off_00002_001002_classes()
#delta_admissables_by_max_sum_using_stack(maxSum,d)
#build_delta_admissables_with_predecessor_data(maxSum,d)
#
#rectify_TravIns_find_LD()
#assign_OM(numDimsToPrint:=2)
#pretty_print_power_of_sequence(KE,pow)
#print_OM(outputVector:=[10,8,7,5])
#assign_and_print_OM(numDimsToPrint:=2,outputVector:=[10,8,7,5])
#diff_extractor(TR,SR,outputVector:=[10,8,7,5])
#quick_extract_and_store_diffs()
#quick_extract_and_store_initial_diff_string(len,sourceStarts:="no gap")
#apply_stored_diffs_and_assign_and_print_OM(numDimsToPrint:=2,outputVector:=[10,8,7,5])
#
#find_RL_coordinates(S)
#find_RL_coordinates_with_hints(S,hints:=[])
#find_RL_coordinates_with_consecutive_hints(S,hints:=[])
#differential_coords_finder(diff,sEqualityPositions:=false,tEqualityPositions:=false)
#
#*double_class(inds)
#kill_class(inds)
#double_rMinusOne(dwhat)
#differential_upgrader(diff,sDescriptor,sData,tDescriptor,tData)
#*differential_squarer(diff)
#all_ordered_partitions_with_sum_at_most(mAx)
#
#*implement_diff(difl)
#*implement_diff_if_in_range_TF(difl)
#*implement_diff_if_in_range_TF_with_some_squares(difl,numSquares:=2^31-1)
#implement_diff_and_all_squares_if_in_range_TF_quick(difl)
#string_of_length_one_sequences_for_squares_index_finder(N_so_far,most_recent_length)
#
#first_round_of_differentials()
#second_round_of_differentials()

#*=out of date

new_dlog:=proc()
 global LogFilename,outputStream,outputStreamOpenFlag;
 if not type(outputStreamOpenFlag,'integer') then
  outputStreamOpenFlag:=-1;
 fi;
 if outputStreamOpenFlag=-1 then
  LogFilename:=StringTools[FormatTime]("c:/maple_logs/%m%d_%H%M%S.txt");
  outputStream:=fopen(LogFilename,WRITE);
  outputStreamOpenFlag:=1;
  timed_message("new dlog opened (",LogFilename,")");
 elif outputStreamOpenFlag=0 then
  error "you've already opened and closed the file - use reopen_dlog()";
 elif outputStreamOpenFlag=1 then
  error "the file is already open!"
 fi;
 return NULL;
end proc:
force_new_dlog:=proc()
 global LogFilename,outputStream,outputStreamOpenFlag;
 if outputStreamOpenFlag=1 then
  close_dlog();
 fi;
 if outputStreamOpenFlag=0 then
  outputStreamOpenFlag:="forcing new dlog";
  timed_message("abandoning old dlog (",LogFilename,")");
 fi;
 new_dlog();
 return NULL;
end proc:
close_dlog:=proc()
 global LogFilename,outputStream,outputStreamOpenFlag;
 if outputStreamOpenFlag<>1 then
  if outputStreamOpenFlag=0 then
   error "the file has already been closed";
  else
   error "the file probably never existed";
  fi;
 else
  fclose(LogFilename);
  outputStreamOpenFlag:=0;
  timed_message("dlog closed (",LogFilename,")");
 fi;
 return NULL;
end proc:
reopen_dlog:=proc()
 global LogFilename,outputStream,outputStreamOpenFlag;
 if outputStreamOpenFlag<>0 then
  if outputStreamOpenFlag=1 then
   error "the file is open already";
  else
   error "the file probably never existed";
  fi;
 else
  outputStream:=fopen(LogFilename,APPEND);
  outputStreamOpenFlag:=1;
  timed_message("dlog reopened (",LogFilename,")");
 fi;
 return NULL;
end proc:
ensure_dlog_open:=proc()
 if outputStreamOpenFlag=0 then
  reopen_dlog();
 elif outputStreamOpenFlag<>1 then
  new_dlog();
 fi;
end proc:
save_dlog:=proc()
 global LogFilename,outputStream,outputStreamOpenFlag;
 if outputStreamOpenFlag<>1 then
  if outputStreamOpenFlag=0 then
   error "the file has already been closed";
  else
   error "the file probably never existed";
  fi;
 else
  fclose(LogFilename);
  outputStream:=fopen(LogFilename,APPEND);
  timed_message("dlog closed and reopened (",LogFilename,")");
 fi;
 return NULL;
end proc:
dlog:=proc(obj,end_entry_string:=",\n")
 global LogFilename,outputStream,outputStreamOpenFlag;
 if outputStreamOpenFlag<>1 then
  if outputStreamOpenFlag=0 then
   error "the file has been closed";
  else
   error "the file probably never existed";
  fi;
 else
  fprintf(outputStream, cat(convert(obj,string),end_entry_string));
 fi;
 return NULL;
end proc:
timed_message:=proc()
 UserFeedback(StringTools[FormatTime]("%H:%M:%S: "),args);
end proc:
timed_dlog:=proc()
 local ans,i,Listo;Listo:=[args];
 ans:=StringTools[FormatTime]("%a%l:%M:%S%p: ");
 for i to nops(Listo) do
  ans:=cat(ans,convert(Listo[i],'string'));
 od;
 dlog(ans);
 NULL;
end proc:

set_dimensions:=proc(cTD,d)
 global calcToDimension,dValue;
 calcToDimension:=cTD;dValue:=d;
 timed_message("set dimensions: up to the ",calcToDimension,"-stem on the ",dValue,"-sphere");
 return NULL;
end proc:

delta_admissables_by_max_sum_using_stack:=proc(maxSum,d)
 local ADMISlist,AMLcount,q,ent,j,PostReln,sumSoFar;
 ADMISlist:=Table(): AMLcount:=0:
 q := stack[new]([]):
 while not stack[empty](q) do
  ent:=stack[pop](q);
  AMLcount:=AMLcount+1:
  ADMISlist[AMLcount]:=ent;
  sumSoFar:=sum(ent[k],k=1..nops(ent));
  for j from min(maxSum-sumSoFar,(sumSoFar+nops(ent)+d))
          to `if`(nops(ent)>0,2*ent[1],2) by -1 do
   stack[push]([j,op(ent)],q);
  od;
 od:
 [seq(ADMISlist[j],j=1..AMLcount)];
end proc:

build_delta_admissables_with_predecessor_data:=proc(maxSum,d)
 local ADMISlist,AMLcount,q,ent,j,PostReln,sumSoFar;
 global delta_admissables,predecessor_data;
 ADMISlist:=Table(): AMLcount:=0:
 q := stack[new]([[],0]):
 while not stack[empty](q) do
  ent:=stack[pop](q);
  AMLcount:=AMLcount+1:
  ADMISlist[AMLcount]:=ent;
  sumSoFar:=sum(ent[1][k],k=1..nops(ent[1]));
  for j from min(maxSum-sumSoFar,(sumSoFar+nops(ent[1])+d))
          to `if`(nops(ent[1])>0,2*ent[1][1],2) by -1 do
   stack[push]([[j,op(ent[1])],AMLcount],q);
  od;
 od:
 delta_admissables:=[seq(ExcessFormatSingle(ADMISlist[j][1]),j=1..AMLcount)];
 #so that delta_admissables ends up in excess form!
 predecessor_data:=[seq(ADMISlist[j][2],j=1..AMLcount)];
 return NULL;
end proc:

build_RL_and_RLlookup:=proc()
 global RL,nops_RL,calcToDimension,dValue,
        string_of_length_one_sequences_for_squares_index_finder,
        RLlookup,delta_admissables,predecessor_data;
 local I2lists,I3lists,newInterface,ans,ILIST,inclusionLists,
       inclusionList,oldInterface,prevLength,m,ISEQ,tempo,i,j;
 forget(string_of_length_one_sequences_for_squares_index_finder);
 timed_message("building RL for calculation up to dimension ",calcToDimension);
 build_delta_admissables_with_predecessor_data(calcToDimension,dValue);
 I3lists:=[seq(SqCompsMi(M,0),M=-1..11)]:
 I2lists:=[seq(SqCompsMi(M,2),M=-1..11)]:
 newInterface:=[seq(2^(i+1)+dValue-2,i=1..max(seq(nops(delta_admissables[i]),i=1..nops(delta_admissables))))];
 inclusionLists:=[];
 for ILIST in [I2lists,I3lists,I3lists,I3lists,I3lists,I3lists,I3lists,I3lists,
               I3lists,I3lists,I3lists,I3lists,I3lists,I3lists,I3lists,I3lists] do
  inclusionList:=[];
  oldInterface:=remove(x->x=2^31-1,newInterface):
  newInterface:=map(x->2^31-1,oldInterface):
  for prevLength from 1 to nops(oldInterface) do
   m:=prevLength - 1;
   for ISEQ in ILIST[m+2] do
    tempo:=2^(nops(ISEQ))*oldInterface[m+1]
           +(2^(nops(ISEQ))-1)*(m+2)
           -nops(ISEQ)-add((2^i-1)*ISEQ[i],i=1..nops(ISEQ));
    if tempo<=calcToDimension and tempo<newInterface[nops(ISEQ)] then
     newInterface[nops(ISEQ)]:=tempo;
    fi;
    if tempo<calcToDimension then
     inclusionList:=[op(inclusionList),ISEQ]
    fi;
   od;
  od:
  #print("interface ",newInterface);  print("list ",inclusionList);  print("");
  if nops(inclusionList)<>0 then
   inclusionLists:=[[[],op(inclusionList)],op(inclusionLists)];
  fi;
 od:
 RL:=[op(inclusionLists),delta_admissables];
 nops_RL:=nops(RL);
 timed_message("built RL[1..",nops_RL,"] with dimensions ",map(x->nops(x),RL));
 RLlookup:=Table();
 for i from -1 to -nops_RL by -1 do
  for j from 1 to nops(RL[i]) do
   RLlookup(i,op(RL[i][j])):=j;
  od;
 od: 
 timed_message("built lookup table inverting RL:N*N-->seq");
 return NULL;
end proc:

find_RL_coordinates:=proc(S)
 global RL,nops_RL,RLlookup;
 local i,ans,T;
 if nops(S)>nops_RL then
  return 0;
 fi; 
 ans:=[];
 for i from -1 to -nops(S) by -1 do
   T:=RLlookup(i,op(S[i]));
   if not type(T,'integer') then return 0; fi;
   ans:=[T,op(ans)];
 od;
 return [seq(1,asd=1..(nops_RL-nops(S))),op(ans)];
end proc:


find_RL_coordinates_with_hints:=proc(S,hints:=[])
 #hints is a list like [[-3,5],[-2,47]] indicating some known positions
 #which must be indexed by negative numbers like -2 and -3 to work
 global RL,nops_RL,RLlookup;
 local i,ans,T,hfind;
 if nops(S)>nops_RL then
  return 0;
 fi; 
 ans:=[];
 for i from -1 to -nops(S) by -1 do
   hfind:=ListTools[Search](i,map(x->x[1],hints));
   if hfind=0 then
    T:=RLlookup(i,op(S[i]));
    if not type(T,'integer') then return 0; fi;
   else
    T:=hints[hfind][2];
    if T=0 then return 0; fi;
   fi;
   ans:=[T,op(ans)];
 od;
 return [seq(1,asd=1..(nops_RL-nops(S))),op(ans)];
end proc:

find_RL_coordinates_with_consecutive_hints:=proc(S,hints:=[])
 #hints is a list like [2,5,47] indicating the rightmost positions
 global RL,nops_RL,RLlookup;
 local i,ans,RLglance;
 if nops(S)>nops_RL then
  return 0;
 fi; 
 ans:=hints;
 for i from -1-nops(hints) to -nops(S) by -1 do
  RLglance:=RLlookup(i,op(S[i]));
  if not type(RLglance,'integer') then return 0; fi;
  ans:=[RLglance,op(ans)];
 od;
 return [seq(1,asd=1..(nops_RL-nops(S))),op(ans)];
end proc:

StatMat_TravIns_starter:=proc()
 global calcToDimension,dValue,RL;
 local RLs,outTable,pTable,i,j,excess,I2Evul,newDimn,pLastLoc,pInitLoc,I1vulnerabilities,I1lengths,
       I1tMs,I2vulnerabilities,I2ellPlusEnn2,I2exc,I2lengths;
 outTable:=rtable(1..nops(RL[-2]),1..nops(RL[-1]),storage=sparse);
 pTable:=rtable(1..nops(RL[-2]),1..nops(RL[-1]),storage=sparse);
 I1vulnerabilities:=map(x->evalb(nops(x)>2 and add(x[i],i=1..nops(x))=dValue+nops(x)-1),RL[-1]);
 I1lengths:=map(x->nops(x),RL[-1]);
 I1tMs:=map(x->dValue+add((2^i-1)*x[i],i=1..nops(x)),RL[-1]);
 I2vulnerabilities:=map(x->evalb(x=[] or x[-1]>2) ,RL[-2]);
 I2ellPlusEnn2:=map(x->nops(x)+add((2^i-1)*x[i],i=1..nops(x)),RL[-2]);
 I2exc:=map(x->`if`(x=[],-1,add(x[i],i=1..nops(x))),RL[-2]);
 I2lengths:=map(x->nops(x),RL[-2]);
 pInitLoc:="finished";
 for i to nops(RL[-2]) do
  for j to nops(RL[-1]) do
   if I2exc[i]<I1lengths[j] and not (I1vulnerabilities[j] and I2vulnerabilities[i]) then
    newDimn:=2^(I2lengths[i])*(I1tMs[j]+I1lengths[j]+1)-(I1lengths[j]+1)-I2ellPlusEnn2[i];
    if newDimn<=calcToDimension then
     outTable[i,j]:=newDimn;
     if pInitLoc="finished" then
      pInitLoc:=[i,j]; 
     else
      pTable[op(pLastLoc)]:=[i,j];
     fi;
     pLastLoc:=[i,j];
    fi;
   fi;
  od;
 od;
 pTable[op(pLastLoc)]:="finished";
 timed_message("calculated StatMat_TravIns_starter");
 return [outTable,pTable,pInitLoc];
end proc:

build_StatMat_TravIns:=proc(DataSoFar:="none")
 global StatMat,TravIns,calcToDimension,dValue,RL,nops_RL,diffCounter;
 local outTable,cp,fInds,iInd,currRLlen,prevRLlen,currRLdim,currRLexc,
       newDimn,iterDims,pTable,pInitLoc,pLastLoc,DSFsize,T;
 if DataSoFar="none" then
  timed_message("commencing build of StatMat and TravIns");
  diffCounter:=0;
  if map(x->x[1],RL)<>map(x->[],RL) then
   error "need RL[i][1]=[] for all i";
  fi;
  return build_StatMat_TravIns(StatMat_TravIns_starter());
 fi;
 DSFsize:=rtable_num_dims(DataSoFar[1]);
 if DSFsize=nops_RL then
  StatMat:=DataSoFar[1];
  TravIns:=[DataSoFar[2],DataSoFar[3]];
  T:=TravIns[2];
  while T<>"finished" do
   StatMat[op(T)]:=[1,StatMat[op(T)]];
   T:=TravIns[1][op(T)];
  od:
  timed_message("StatMat and TravIns done, dimensions ",map(x->[seq(i,i=x)][-1],[rtable_dims(StatMat)]));
  return NULL;
 fi;
 outTable:=rtable(1..nops(RL[-1-DSFsize]),
                  rtable_dims(DataSoFar[1]),storage=sparse);
 pTable:=rtable(rtable_dims(outTable),storage=sparse);
 pInitLoc:="finished";
 currRLlen:=map(x->nops(x),RL[-1-DSFsize]);
 prevRLlen:=map(x->nops(x),RL[-DSFsize]);
 currRLdim:=map(x->add((2^i-1)*x[i],i=1..nops(x)),
                RL[-1-DSFsize]);
 currRLexc:=map(x->`if`(x=[],-1,add(x[i],i=1..nops(x))),
                RL[-1-DSFsize]);
 fInds:=DataSoFar[3];
 while fInds<>"finished" do
   for iInd to nops(currRLlen) do
    if currRLexc[iInd]<prevRLlen[fInds[1]] then
     newDimn:=(2^(currRLlen[iInd])  )*DataSoFar[1][op(fInds)]
             +((2^(currRLlen[iInd]))-1)*(prevRLlen[fInds[1]]+1)
             -currRLlen[iInd]-currRLdim[iInd];
#     UserFeedback([RL[-1-DSFsize][iInd],seq(RL[i][fInds[i]],i=-DSFsize..-1)]);
     if newDimn<=calcToDimension then
      outTable[iInd,op(fInds)]:=newDimn;
      if pInitLoc="finished" then
       pInitLoc:=[iInd,op(fInds)]; 
      else
       pTable[op(pLastLoc)]:=[iInd,op(fInds)];
      fi;
      pLastLoc:=[iInd,op(fInds)];
     fi;
    fi;
   od;
   fInds:=DataSoFar[2][op(fInds)];
 od;
 pTable[op(pLastLoc)]:="finished";
 if rtable_num_dims(outTable)<nops_RL then
  timed_message("computed ",rtable_num_dims(outTable)," out of ",nops_RL," dimensions deep");
 fi;
 return build_StatMat_TravIns([outTable,pTable,pInitLoc]);
end proc:

double_class:=proc(inds)
 global StatMat,calcToDimension;
 if StatMat[op(inds)][1]<>0 then
  StatMat[op(inds)][1]:=2*StatMat[op(inds)][1];
  if StatMat[op(inds)][1]*StatMat[op(inds)][2]>calcToDimension then
   StatMat[op(inds)]:=0;
  fi;
 else
  error "this class is dead";
 fi;
 return NULL;
end proc:

kill_class:=proc(inds)
 global StatMat;
 if StatMat[op(inds)][1]<>0 then
  StatMat[op(inds)]:=0;
 else
  error "this class is already dead";
 fi;
 return NULL;
end proc:

rectify_TravIns_find_LD:=proc()
 global StatMat,TravIns,LowestDimension;
 local T;
 LowestDimension:=2^31-1;
 T:=TravIns[2];
 while T<>"finished" and StatMat[op(T)]=0 do
  TravIns[2]:=TravIns[1][op(T)];
  T:=TravIns[2];
 od;
 while T<>"finished" do
  LowestDimension:=min(LowestDimension,StatMat[op(T)][1]*StatMat[op(T)][2]);
  if TravIns[1][op(T)]<>"finished" and StatMat[op(TravIns[1][op(T)])]=0 then
   TravIns[1][op(T)]:=TravIns[1][op(TravIns[1][op(T)])]:
  else
   T:=TravIns[1][op(T)];
  fi;
 od:
 return NULL;
end proc:

pretty_print_power_of_sequence:=proc(KE,pow)
local ANS,i;
 ANS:='e^pow':
 for i from nops(KE) to 1 by -1 do 
  if nops(KE[i])>0 then 
   ANS:=[delta,SQa,SQb,SQc,SQd,SQe,SQf,SQg,SQh,SQi,SQj,SQk][1+nops(KE)-i][op(KE[i])]*ANS;
  fi;
 od;
 ANS; 
end proc:

assign_OM:=proc(numDimsToPrint:=2)
 #automatically runs rectify_TravIns_find_LD beforehand
 global StatMat,TravIns,LowestDimension,OM,calcToDimension,diffCounter;
 local T,L,i;
 rectify_TravIns_find_LD();
 L:=[];
 T:=TravIns[2];
 while T<>"finished" do
  if StatMat[op(T)][1]*StatMat[op(T)][2] <= LowestDimension+numDimsToPrint-1 then
   L:=[op(L),T];
  fi;
  T:=TravIns[1][op(T)];
 od;
 #L:=map(x->[x,remove(y->y=[],[seq(RL[i][x[i]],i=1..nops(x))]),op(StatMat[op(x)])],L);
 L:=map(x->[x,remove(y->y=[],[seq(RL[i][x[i]],i=1..nops(x))]),op(StatMat[op(x)]),StatMat[op(x)][1]*StatMat[op(x)][2],
            2^(add(nops(RL[i][x[i]]),i=1..nops(x)-1))*
            StatMat[op(x)][1]*(dValue+1+nops(RL[-1][x[-1]])
            +add(RL[-1][x[-1]][j]*(2^j-1),j=1..nops(RL[-1][x[-1]])))-1   ],L);
 #[1=location,2=printout,3=power,4=dimensionOfFirstPower,5=t-s,6=t]
 L:=map(x->[op(x),x[6]-x[5],pretty_print_power_of_sequence(x[2],x[3])   ,   E2DegreePRHomEltNoZero(unExcessFormatPR([[x[3],x[2]]]),dValue)],L);
 #[...,7=s,8=prettyprint,9=allE2dimensions(forDebug)]
 L:=sort(L,(x,y)->(x[5]<y[5] or 
                           (x[5]=y[5] and x[6]<y[6])) or
                           (x[5]=y[5] and x[6]=y[6] and
  lexorder(StringTools[Reverse](convert(ListTools[Flatten](x[2]),string)),
           StringTools[Reverse](convert(ListTools[Flatten](y[2]),string)))
                            )):
 for i to nops(L) do
  L[i]:=[op(L[i]),i];
 od;
 L:=[['loc',`elt`,`pow`,`1powDim`,`t-s`,`t`,`s`,`elt`,`dims`,` `],op(L)];
 OM:=Matrix(L);
 if nops(L)>1 then
  timed_message("after ",diffCounter," differentials, OM has ",nops(L)-1," entries, starting in dimension ",L[2][5]);
  if L[2][5]=calcToDimension then 
   timed_message("------------------------------------final dimension!------------------------------------"); 
  fi;
 else
  timed_message("after ",diffCounter," differentials, we've cleared up to dimension ",calcToDimension);
 fi;
 return NULL;
end proc:

print_OM:=proc(outputVector:=[10,8,7,5])
 global OM;
 #set the following 2 to 1 to show headings
 print(LinearAlgebra[SubMatrix](OM,[2..-1],outputVector));
 return NULL;
end proc:

assign_and_print_OM:=proc(numDimsToPrint:=2,outputVector:=[10,8,7,5])
 assign_OM(numDimsToPrint);
 print_OM(outputVector);
 return NULL;
end proc:

diff_extractor:=proc(TR,SR,outputVector:=[10,8,7,5])
 global OM;
 print(LinearAlgebra[SubMatrix](OM,[TR+1,SR+1],outputVector));
 #why not test somthing at this point?
 [`?`,cat("d",OM[TR+1,7]-OM[SR+1,7]),OM[SR+1,2],OM[SR+1,3],OM[TR+1,2],OM[TR+1,3],OM[SR+1,1],OM[TR+1,1]];
end proc:

apply_stored_diffs_and_assign_and_print_OM:=proc(numDimsToPrint:=2,outputVector:=[10,8,7,5])
 global ManuallyStoredDiffs;
 local i;
 ensure_dlog_open();
 if assigned(ManuallyStoredDiffs) then
  for i in ManuallyStoredDiffs do
   implement_diff_and_all_squares_if_in_range_TF_quick(i);
  od;
 fi;
 ManuallyStoredDiffs:=[];
 assign_and_print_OM(numDimsToPrint,outputVector);
 return NULL;
end proc:

quick_extract_and_store_diffs:=proc()
 local i,Listo;
 global ManuallyStoredDiffs,diffCounter;
 Listo:=[args];
 timed_message("after ",diffCounter," differentials, storing ",nops(Listo)," differentials:");
 for i to nops(Listo) do
  Listo[i]:=diff_extractor(Listo[i][1],Listo[i][2]);
  if Listo[i][3][-1][2..-1]<>Listo[i][5][-1] then error "I think this last one was wrong" fi;
 od;
 ManuallyStoredDiffs:=Listo;
 return NULL;
end proc:

quick_extract_and_store_initial_diff_string:=proc(len,sourceStarts:="no gap")
 quick_extract_and_store_diffs(seq([i+1,i+`if`(sourceStarts="no gap" or sourceStarts=0,len+1,sourceStarts)],i=0..len-1));
 return NULL;
end proc:

trim_off_00002_001002_classes:=proc()
 global StatMat, TravIns, dValue, RL, nops_RL;
 local OneIndices,ell,ZeroList,temp,TempZeroList,OnePos;
 OneIndices:=[seq(1,i = 1 .. nops_RL-1)];
 StatMat[op(OneIndices),1]:=0;
 for ell from 1 to ilog2(calcToDimension) do
  ZeroList:=[seq(0,dummy=1..ell-1),2];
  temp:=RLlookup(-1,op(ZeroList));
  if type(temp,'integer') then StatMat[op(OneIndices),temp]:=0; fi;
  for OnePos from 2 to ell do
   TempZeroList:=ZeroList;
   TempZeroList[-OnePos]:=1;
   temp:=RLlookup(-1,op(TempZeroList));
   if type(temp,'integer') then StatMat[op(OneIndices),temp]:=0; fi;
  od;
 od;
 timed_message("trimmed off the 00002 and 001002 classes");
 return NULL;
end proc:

implement_diff:=proc(difl)
 global RL,StatMat,diffCounter;
 if nops(StatMat[op(difl[7])])<>2 or nops(StatMat[op(difl[8])])<>2 then
  error "either source or target is already dead or broken";
 fi;
 if difl[4]<>StatMat[op(difl[7])][1] then
  error "the source power is wrong";
 fi;
 if difl[6]<>StatMat[op(difl[8])][1] then
  error "the target power is likely to be wrong";
 fi;
 kill_class(difl[8]);
 double_class(difl[7]);
 diffCounter:=diffCounter+1;
 if outputStreamOpenFlag=0 then
  reopen_dlog();
 elif outputStreamOpenFlag<>1 then
  new_dlog();
 fi;
 dlog(difl);
 return NULL;
end proc:

implement_diff_if_in_range_TF:=proc(difl)
 #implements a differential if it's in range, returning true/false
 global RL,StatMat;
 if difl=0 or StatMat[op(difl[7])]=0 or StatMat[op(difl[8])]=0 then
  return false;
 fi;
 implement_diff(difl);
 return true;
end proc:

implement_diff_if_in_range_TF_with_some_squares:=proc(difl,numSquares:=2^31-1)
 local counter,diff;
 counter:=0;diff:=difl;
 while counter<=numSquares and implement_diff_if_in_range_TF(diff) do
  if counter<numSquares then
   diff:=differential_squarer(diff);
  fi;
  counter:=counter+1;
 od;
 return evalb(counter<>0);
end proc:

differential_coords_finder:=proc(diff,sEqualityPositions:=false,tEqualityPositions:=false)
 #will find the coordinates of the elements in a differential if they are missing
 #if no hints are to be supplied, stick in false or "no hints"
 #if diff[7..8] are present, will automatically refind them unless passed "done" or "same"
 #if diff[7..8] present but partially incorrect, will correct them - can be passed a short list...
 #...of negative integer indices where the coordinates given are known.
 #finally, last two entries can be integers which state how many of the final entries of...
 #...diff[7] and diff[8] are correct.
 local output;
 output:=diff[1..6];
 if type(sEqualityPositions,integer) then
  output:=[op(output),find_RL_coordinates_with_consecutive_hints(diff[3],diff[7][-sEqualityPositions..-1])];
 elif sEqualityPositions="no hints" or sEqualityPositions=false then
  output:=[op(output),find_RL_coordinates(diff[3])];
 elif sEqualityPositions="same" or sEqualityPositions="done" then
  output:=[op(output),diff[7]];
 else
  output:=[op(output),find_RL_coordinates_with_hints(diff[3],
                 map(x->[x,diff[7][x]],sEqualityPositions))];
 fi;
 if output[7]=0 then return 0; fi;
 if type(tEqualityPositions,integer) then
  output:=[op(output),find_RL_coordinates_with_consecutive_hints(diff[5],diff[8][-tEqualityPositions..-1])];
 elif tEqualityPositions="no hints" or tEqualityPositions=false then
  output:=[op(output),find_RL_coordinates(diff[5])];
 elif tEqualityPositions="same" or tEqualityPositions="done" then
  output:=[op(output),diff[8]];
 else
  output:=[op(output),find_RL_coordinates_with_hints(diff[5],
                 map(x->[x,diff[8][x]],tEqualityPositions))];
 fi;
 if output[8]=0 then return 0; fi;
 return output;
end proc:

double_rMinusOne:=proc(dwhat)
 option remember;
 local SR;
 if not type("hi",'string') then error "not a string" fi;
 SR:=StringTools[SelectRemove]( StringTools[IsDigit],  dwhat  );
 if SR[2]<>"d" or dwhat[1]<>"d" then error "not of form d123" fi;
 SR[1];
 cat("d",2*parse(%)-1);
end proc:

all_ordered_partitions_with_sum_at_most:=proc(mAx) option remember;
 return [seq(seq(op(combinat[composition](n,i)),i=1..n),n=1..mAx)];
end proc:

differential_upgrader:=proc(diff,sDescriptor,sData,tDescriptor,tData)
 #changes a differential in one of 5*5 simple ways:
 #1. "square", 2. "add new sequence to left"
 #3. "append to left of leftmost nontrivial sequence"
 #4. "completely replace, (k+...+ell2)+=1, inputting [S,pow]"
 #5. "add top 1-element sequence to left"
 local output,sHint,tHint;
 if diff=0 then return 0 fi;
 output:=diff;
 output[3]:=remove(x->x=[],output[3]);
 output[5]:=remove(x->x=[],output[5]);
 if sDescriptor="square" then
  output[4]:=2*output[4];
  sHint:="done";
 elif sDescriptor="add new sequence to left" then
  sHint:=nops(output[3]);
  output[3]:=[sData,op(output[3])];
 elif sDescriptor="add top 1-element sequence to left" then
  sHint:=nops(output[3]);
  output[3]:=[[nops(output[3][1])-1],op(output[3])];
 elif sDescriptor="append to left of leftmost nontrivial sequence" then
  sHint:=nops(output[3])-1;
  output[3][1]:=[op(sData),op(output[3][1])];
 elif sDescriptor="completely replace, (k+...+ell2)+=1, inputting [S,pow]" then
  output[3]:=sData[1];output[4]:=sData[2];
  sHint:="no hints";
 else
  error "I don't recognise the command";
 fi;
 if tDescriptor="square" then
  output[6]:=2*output[6];
  tHint:="done";
 elif tDescriptor="add new sequence to left" then
  tHint:=nops(output[5]);
  output[5]:=[tData,op(output[5])];
 elif tDescriptor="add top 1-element sequence to left" then
  tHint:=nops(output[5]);
  output[5]:=[[nops(output[5][1])-1],op(output[5])];
 elif tDescriptor="append to left of leftmost nontrivial sequence" then
  tHint:=nops(output[5])-1;
  output[5][1]:=[op(tData),op(output[5][1])];
 elif tDescriptor="completely replace, (k+...+ell2)+=1, inputting [S,pow]" then
  output[5]:=tData[1];output[6]:=tData[2];
  tHint:="no hints";
 else
  error "I don't recognise the command";
 fi;
 output[2]:=double_rMinusOne(output[2]);
 output:=differential_coords_finder(output,sHint,tHint);
 return output;
end proc:

differential_squarer:=proc(diff)
 return differential_upgrader(diff,"square","meh","add top 1-element sequence to left","meh");
end proc:

string_of_length_one_sequences_for_squares_index_finder:=proc(N_so_far,most_recent_length) option remember;
 global RL,nops_RL;
 local ans,mrl,search_loc;
 ans:=[]; mrl:=most_recent_length;
 while nops(ans)+N_so_far<nops_RL and mrl<>0 do
  search_loc:=RLlookup(-N_so_far-nops(ans)-1,mrl-1);
  if type(search_loc,'integer') then
   ans:=[search_loc,op(ans)];
   mrl:=1;
  else
   mrl:=0;
  fi;
 od;
 return ans;
end proc:

implement_diff_and_all_squares_if_in_range_TF_quick:=proc(difl)
 global StatMat,calcToDimension,diffCounter,nops_RL;
 local counter,diff,dim,num_of_squarings,SM7,SM8,trimmedTargIndex,prefixes;
 if difl=0 then return false; fi;
 if difl[4]<>1 or difl[6]<>1 then error "I expected only first power to first power"; fi; 
 SM7:=StatMat[op(difl[7])]; SM8:=StatMat[op(difl[8])];
 if SM7=0 then return false; fi;
 if SM8=0 or SM7[1]<>1 or SM8[1]<>1 then error "this class has already been messed with"; fi;
 if SM7[2]<>SM8[2]+1 then error "dimensions don't differ by 1"; fi;
 num_of_squarings:=ilog2( (1+calcToDimension)/(1+SM8[2]) );
 trimmedTargIndex:=remove(x->x=1,difl[8]);
 prefixes:=string_of_length_one_sequences_for_squares_index_finder(nops(trimmedTargIndex),
            nops(RL[-nops(trimmedTargIndex)][trimmedTargIndex[1]]))[-num_of_squarings..-1];
 dlog(difl); diffCounter:=diffCounter+1;
 StatMat[op(difl[7])]:=0;
 for counter from 0 to nops(prefixes) do
  StatMat[seq(1,hhh=counter+nops(trimmedTargIndex)+1..nops_RL),op(prefixes[-counter..-1]),op(trimmedTargIndex)]:=0;
 od;
 return true;
end proc:

first_round_of_differentials:=proc()
 #slower than the previous version, but easier to read and emulate!
 global RL,StatMat,dValue,outputStreamOpenFlag,diffCounter;
 local ell1,exc1,a,i,srcI1,trgS,diff,srcCoords,trgCoords,diffCounterStarting;
 timed_message("starting first round of differentials");
 ensure_dlog_open();
 diffCounterStarting:=diffCounter;
 for i from 2 to nops(RL[-1]) do
  srcI1:=RL[-1][i];
  a:=remove(x->x=0,srcI1);
  if a<>[1,dValue] and a<>[dValue] then
   ell1:=nops(srcI1);
   exc1:=add(srcI1[gh],gh=1..ell1);
   a:=dValue+ell1-exc1;
   if a<ell1-1 and a>=1 then
    trgS:=[[a],srcI1[2..-1]];
   else
    error "this is strange";
   fi;
   diff:=[`rnd1`,cat("d",a),[srcI1],1,trgS,1,[i],"?"];
   diff:=differential_coords_finder(diff,1);
   implement_diff_and_all_squares_if_in_range_TF_quick(diff);
  fi;
 od;
 timed_message("finished first round of differentials - there were ",diffCounter-diffCounterStarting);
 return NULL;
end proc:

second_round_of_differentials:=proc()
 global RL,StatMat,dValue,outputSreamOpenFlag,diffCounter;
 local ell1,exc1,jay,i,srcI1,srcS,trgS,srcPow,trgPow,`initdiff`,diffCounterStarting,
       `diff`,`diff0_0`,`diff1_1`,`diff0.0_10`,`diff0.0.0_0.10`,`diff0.0.0.0_10.10`,
       xtra,`xtradiff`,`xtradiff0_0`,`xtradiff1_1`,`xtradiff0.1_11`,`xtradiff0.0_20`,`xtradiff10_10`;
 timed_message("starting second round of differentials");
 ensure_dlog_open();
 diffCounterStarting:=diffCounter;
 for i from 2 to nops(RL[-1]) do
  srcI1:=RL[-1][i];
  ell1:=nops(srcI1);
  exc1:=add(srcI1[gh],gh=1..ell1); 
  for jay from 2+dValue+ell1-exc1 to ell1-1 do
   srcS:=[[jay],srcI1];
   trgS:=[[jay-1-(dValue+ell1-exc1),dValue+ell1-exc1],srcI1[2..-1]];
   srcPow:=1;
   trgPow:=1;
   `initdiff`:=differential_coords_finder([`rnd2`,cat("d",2*(dValue+ell1-exc1-1)+1),srcS,srcPow,trgS,trgPow,[i]],1,false);
   if implement_diff_and_all_squares_if_in_range_TF_quick(`initdiff`) then   
    `diff0_0`:=differential_upgrader(`initdiff`,"add new sequence to left",[0],"add new sequence to left",[0]);
    if implement_diff_and_all_squares_if_in_range_TF_quick(`diff0_0`) then
     `diff0.0_10`:=differential_upgrader(`diff0_0`,"add new sequence to left",[0],
                "append to left of leftmost nontrivial sequence",[1]);
     if implement_diff_and_all_squares_if_in_range_TF_quick(`diff0.0_10`) then
      `diff0.0.0_0.10`:=differential_upgrader(`diff0.0_10`,"add new sequence to left",[0],"add new sequence to left",[0]);
      if implement_diff_and_all_squares_if_in_range_TF_quick(`diff0.0.0_0.10`) then
       `diff0.0.0.0_10.10`:=differential_upgrader(`diff0.0.0_0.10`,"add new sequence to left",[0],
                "append to left of leftmost nontrivial sequence",[1]);
       implement_diff_and_all_squares_if_in_range_TF_quick(`diff0.0.0.0_10.10`);
      fi;
     fi;
    fi;
    for xtra in all_ordered_partitions_with_sum_at_most(ell1-jay-1) do
     `xtradiff`:=differential_upgrader(`initdiff`,
              "append to left of leftmost nontrivial sequence",xtra,
              "append to left of leftmost nontrivial sequence",xtra);
     if implement_diff_and_all_squares_if_in_range_TF_quick(`xtradiff`) then
      `xtradiff0_0`:=differential_upgrader(`xtradiff`,"add new sequence to left",[0],"add new sequence to left",[0]);
      implement_diff_and_all_squares_if_in_range_TF_quick(`xtradiff0_0`);
      `xtradiff1_1`:=differential_upgrader(`xtradiff`,"add new sequence to left",[1],"add new sequence to left",[1]);
      implement_diff_and_all_squares_if_in_range_TF_quick(`xtradiff1_1`);
      if nops(xtra)=1 then
       `xtradiff0.1_11`:=differential_upgrader(`xtradiff1_1`,"add new sequence to left",[0],
                "append to left of leftmost nontrivial sequence",[1]);
       implement_diff_and_all_squares_if_in_range_TF_quick(`xtradiff0.1_11`);
       `xtradiff0.0_20`:=differential_upgrader(`xtradiff0_0`,"add new sequence to left",[0],
                "append to left of leftmost nontrivial sequence",[2]);
       implement_diff_and_all_squares_if_in_range_TF_quick(`xtradiff0.0_20`);
       `xtradiff10_10`:=differential_upgrader(`xtradiff`,"add new sequence to left",[1,0],"add new sequence to left",[1,0]);
       implement_diff_and_all_squares_if_in_range_TF_quick(`xtradiff10_10`);
      fi;
     fi;
    od;
   fi;
  od;
 od;
 timed_message("finished 2nd round of differentials - there were ",diffCounter-diffCounterStarting);
 return NULL;
end proc:




########### begin program
set_dimensions(2000,2);
fileNm:=cat(cat(cat("C:\\maple_output\\afterRound2_S",dValue),"dim"),calcToDimension):
if FileTools[Exists](fileNm)=false then
 build_RL_and_RLlookup();
 build_StatMat_TravIns();
 trim_off_00002_001002_classes();
 assign_and_print_OM();
 first_round_of_differentials();
 close_dlog();
 assign_and_print_OM();
 second_round_of_differentials();
 assign_and_print_OM();
 close_dlog();
 save RL, StatMat, TravIns, diffCounter, RLlookup, cat(fileNm);
else
 read fileNm:
 timed_message("you just loaded the post-round 2 data");
fi;


apply_stored_diffs_and_assign_and_print_OM(2)
quick_extract_and_store_initial_diff_string(1)
#quick_extract_and_store_diffs([1,2],[3,4]);

WAS ABOUT TO IMPROVE THE INITIALISATION OF NEW DIFFS USING the predecessor data, 
WHICH IS UNTESTED as is the new function that builds it



PUT status updates for each round of differentials
Change RLlookup[-1] to a table. - find upper bound on the sizes at each coordinate. -1=empty, 0=0, 1=1,...