new_dlog:=proc()
 global LogFilename,outputStream,outputStreamOpenFlag;
 if not type(outputStreamOpenFlag,'integer') then
  outputStreamOpenFlag:=-1;
 fi;
 if outputStreamOpenFlag=-1 then
  LogFilename:=StringTools[FormatTime]("c:/maple_logs/%d%b_%H%M%S.txt");
  outputStream:=fopen(LogFilename,WRITE);
  outputStreamOpenFlag:=1;
  timed_message("new dlog opened (",LogFilename,")");
 elif outputStreamOpenFlag=0 then
  error "you've already opened and closed the file - use reopen_dlog()";
 elif outputStreamOpenFlag=1 then
  error "the file is already open!"
 fi;
 return NULL;
end proc:
close_dlog:=proc()
 global LogFilename,outputStream,outputStreamOpenFlag;
 if outputStreamOpenFlag<>1 then
  if outputStreamOpenFlag=0 then
   error "the file has already been closed";
  else
   error "the file probably never existed";
  fi;
 else
  fclose(LogFilename);
  outputStreamOpenFlag:=0;
  timed_message("dlog closed (",LogFilename,")");
 fi;
 return NULL;
end proc:
reopen_dlog:=proc()
 global LogFilename,outputStream,outputStreamOpenFlag;
 if outputStreamOpenFlag<>0 then
  if outputStreamOpenFlag=1 then
   error "the file is open already";
  else
   error "the file probably never existed";
  fi;
 else
  outputStream:=fopen(LogFilename,APPEND);
  outputStreamOpenFlag:=1;
  timed_message("dlog reopened (",LogFilename,")");
 fi;
 return NULL;
end proc:
save_dlog:=proc()
 global LogFilename,outputStream,outputStreamOpenFlag;
 if outputStreamOpenFlag<>1 then
  if outputStreamOpenFlag=0 then
   error "the file has already been closed";
  else
   error "the file probably never existed";
  fi;
 else
  fclose(LogFilename);
  outputStream:=fopen(LogFilename,APPEND);
  timed_message("dlog closed and reopened (",LogFilename,")");
 fi;
 return NULL;
end proc:
dlog:=proc(obj)
 global LogFilename,outputStream,outputStreamOpenFlag;
 if outputStreamOpenFlag<>1 then
  if outputStreamOpenFlag=0 then
   error "the file has been closed";
  else
   error "the file probably never existed";
  fi;
 else
  fprintf(outputStream, cat(convert(obj,string),"\n"));
 fi;
 return NULL;
end proc:
timed_message:=proc()
 local ans,i,Listo;Listo:=[args];
 ans:=StringTools[FormatTime]("%a%l:%M:%S%p: ");
 for i to nops(Listo) do
  ans:=cat(ans,convert(Listo[i],'string'));
 od;
 writeline(default,ans);
 NULL;
end proc:
timed_dlog:=proc()
 local ans,i,Listo;Listo:=[args];
 ans:=StringTools[FormatTime]("%a%l:%M:%S%p: ");
 for i to nops(Listo) do
  ans:=cat(ans,convert(Listo[i],'string'));
 od;
 dlog(ans);
 NULL;
end proc:

set_dimensions:=proc(cTD,d)
 global calcToDimension,dValue;
 calcToDimension:=cTD;dValue:=d;
 timed_message("set dimensions: up to the ",calcToDimension,"-stem on the ",dValue,"-sphere");
 return NULL;
end proc:

build_RL:=proc()
 global RL,calcToDimension,dValue;
 local I1list,I2lists,I3lists,newInterface,ans,ILIST,inclusionLists,
       inclusionList,oldInterface,prevLength,m,ISEQ,tempo;
 timed_message("building RL for calculation up to dimension ",calcToDimension);
 I1list:=delAdmissablesByMaxSum(calcToDimension,dValue):
 I3lists:=[seq(SqCompsMi(M,0),M=-1..11)]:
 I2lists:=[seq(SqCompsMi(M,2),M=-1..11)]:
 newInterface:=[seq(2^(i+1)+dValue-2,i=1..max(seq(nops(I1list[i]),i=1..nops(I1list))))];
 inclusionLists:=[];
 for ILIST in [I2lists,I3lists,I3lists,I3lists,I3lists,I3lists,I3lists,I3lists] do
  inclusionList:=[];
  oldInterface:=remove(x->x=2^31-1,newInterface):
  newInterface:=map(x->2^31-1,oldInterface):
  for prevLength from 1 to nops(oldInterface) do
   m:=prevLength - 1;
   for ISEQ in ILIST[m+2] do
    tempo:=2^(nops(ISEQ))*oldInterface[m+1]
           +(2^(nops(ISEQ))-1)*(m+2)
           -nops(ISEQ)-add((2^i-1)*ISEQ[i],i=1..nops(ISEQ));
    if tempo<=calcToDimension and tempo<newInterface[nops(ISEQ)] then
     newInterface[nops(ISEQ)]:=tempo;
    fi;
    if tempo<calcToDimension then
     inclusionList:=[op(inclusionList),ISEQ]
    fi;
   od;
  od:
  #print("interface ",newInterface);  print("list ",inclusionList);  print("");
  if nops(inclusionList)<>0 then
   inclusionLists:=[[[],op(inclusionList)],op(inclusionLists)];
  fi;
 od:
 RL:=[op(inclusionLists),map(ExcessFormatSingle,I1list)];
 timed_message("built RL[1..",nops(RL),"] with dimensions ",map(x->nops(x),RL));
 return NULL;
end proc:

find_RL_coordinates:=proc(S)
 global RL;
 local i,ans,T;
 if nops(S)>nops(RL) then
  return 0;
 fi; 
 ans:=[];
 for i from -1 to -nops(S) by -1 do
   T:=ListTools[Search](S[i],RL[i]);
   if T=0 then return 0; fi;
   ans:=[T,op(ans)];
 od;
 for i from -1-nops(S) to -nops(RL) by -1 do
   ans:=[1,op(ans)];
 od;
 ans;
end proc:

find_RL_coordinates_with_hints:=proc(S,hints:=[])
 #hints is a list like [[-3,5],[-2,47]] indicating some known positions
 #which must be indexed by negative numbers like -2 and -3 to work
 global RL;
 local i,ans,T,hfind;
 if nops(S)>nops(RL) then
  return 0;
 fi; 
 ans:=[];
 for i from -1 to -nops(S) by -1 do
   hfind:=ListTools[Search](i,map(x->x[1],hints));
   if hfind=0 then
    T:=ListTools[Search](S[i],RL[i]);
   else
    T:=hints[hfind][2];
    if T>nops(RL[i]) or RL[i][T]<>S[i] then error "that hint sucked"; fi;
   fi;
   if T=0 then return 0; fi;
   ans:=[T,op(ans)];
 od;
 for i from -1-nops(S) to -nops(RL) by -1 do
   ans:=[1,op(ans)];
 od;
 ans;
end proc:

StatMat_TravIns_starter:=proc()
 global calcToDimension,dValue,RL;
 local RLs,outTable,pTable,i,j,excess,I2Evul,newDimn,pLastLoc,pInitLoc;
 RLs:=[op(RL[1..-2]),map(unExcessFormatSingle,RL[-1])];
 outTable:=rtable(1..nops(RLs[-2]),1..nops(RLs[-1]),storage=sparse);
 pTable:=rtable(1..nops(RLs[-2]),1..nops(RLs[-1]),storage=sparse);
 pInitLoc:="finished";
 for i to nops(RLs[-2]) do
  excess:=`if`(RLs[-2][i]=[],-1,add(RLs[-2][i][j],j=1..nops(RLs[-2][i])));
  I2Evul:=I2vulnerable(RLs[-2][i]);
  for j to nops(RLs[-1]) do
   if excess<nops(RLs[-1][j]) and I2Evul*I1vulnerable(RLs[-1][j],dValue)=0 then
    newDimn:=tMINUSsAdjusted([RLs[-2][i],RLs[-1][j]],dValue);
    if newDimn<=calcToDimension then
     outTable[i,j]:=newDimn;
     if pInitLoc="finished" then
      pInitLoc:=[i,j]; 
     else
      pTable[op(pLastLoc)]:=[i,j];
     fi;
     pLastLoc:=[i,j];
    fi;
   fi;
  od;
 od;
 pTable[op(pLastLoc)]:="finished";
 timed_message("calculated StatMat_TravIns_starter");
 return [outTable,pTable,pInitLoc];
end proc:

build_StatMat_TravIns:=proc(DataSoFar:="none")
 global StatMat,TravIns,calcToDimension,dValue,RL;
 local outTable,cp,fInds,iInd,currRLlen,prevRLlen,currRLdim,currRLexc,
       newDimn,iterDims,pTable,pInitLoc,pLastLoc,DSFsize,T;
 if DataSoFar="none" then
  timed_message("commencing build of StatMat and TravIns");
  if map(x->x[1],RL)<>map(x->[],RL) then
   error "need RL[i][1]=[] for all i";
  fi;
  return build_StatMat_TravIns(StatMat_TravIns_starter());
 fi;
 DSFsize:=rtable_num_dims(DataSoFar[1]);
 if DSFsize=nops(RL) then
  StatMat:=DataSoFar[1];
  TravIns:=[DataSoFar[2],DataSoFar[3]];
  T:=TravIns[2];
  while T<>"finished" do
   StatMat[op(T)]:=[1,StatMat[op(T)]];
   T:=TravIns[1][op(T)];
  od:
  timed_message("StatMat and TravIns done, dimensions ",map(x->[seq(i,i=x)][-1],[rtable_dims(StatMat)]));
  return NULL;
 fi;
 outTable:=rtable(1..nops(RL[-1-DSFsize]),
                  rtable_dims(DataSoFar[1]),storage=sparse);
 pTable:=rtable(rtable_dims(outTable),storage=sparse);
 pInitLoc:="finished";
 currRLlen:=map(x->nops(x),RL[-1-DSFsize]);
 prevRLlen:=map(x->nops(x),RL[-DSFsize]);
 currRLdim:=map(x->add((2^i-1)*x[i],i=1..nops(x)),
                RL[-1-DSFsize]);
 currRLexc:=map(x->`if`(x=[],-1,add(x[i],i=1..nops(x))),
                RL[-1-DSFsize]);
 fInds:=DataSoFar[3];
 while fInds<>"finished" do
   for iInd to nops(currRLlen) do
    if currRLexc[iInd]<prevRLlen[fInds[1]] then
     newDimn:=(2^(currRLlen[iInd])  )*DataSoFar[1][op(fInds)]
             +((2^(currRLlen[iInd]))-1)*(prevRLlen[fInds[1]]+1)
             -currRLlen[iInd]-currRLdim[iInd];
#     UserFeedback([RL[-1-DSFsize][iInd],seq(RL[i][fInds[i]],i=-DSFsize..-1)]);
     if newDimn<=calcToDimension then
      outTable[iInd,op(fInds)]:=newDimn;
      if pInitLoc="finished" then
       pInitLoc:=[iInd,op(fInds)]; 
      else
       pTable[op(pLastLoc)]:=[iInd,op(fInds)];
      fi;
      pLastLoc:=[iInd,op(fInds)];
     fi;
    fi;
   od;
   fInds:=DataSoFar[2][op(fInds)];
 od;
 pTable[op(pLastLoc)]:="finished";
 if rtable_num_dims(outTable)<nops(RL) then
  timed_message("computed ",rtable_num_dims(outTable)," out of ",nops(RL)," dimensions deep");
 fi;
 return build_StatMat_TravIns([outTable,pTable,pInitLoc]);
end proc:

double_class:=proc(inds)
 global StatMat,calcToDimension;
 if StatMat[op(inds)][1]<>0 then
  StatMat[op(inds)][1]:=2*StatMat[op(inds)][1];
  if StatMat[op(inds)][1]*StatMat[op(inds)][2]>calcToDimension then
   StatMat[op(inds)]:=0;
  fi;
 else
  error "this class is dead";
 fi;
 return NULL;
end proc:

kill_class:=proc(inds)
 global StatMat;
 if StatMat[op(inds)][1]<>0 then
  StatMat[op(inds)]:=0;
 else
  error "this class is already dead";
 fi;
 return NULL;
end proc:

rectify_TravIns_find_LD:=proc()
 global StatMat,TravIns,LowestDimension;
 local T;
 LowestDimension:=2^31-1;
 T:=TravIns[2];
 while T<>"finished" and StatMat[op(T)]=0 do
  TravIns[2]:=TravIns[1][op(T)];
  T:=TravIns[2];
 od;
 while T<>"finished" do
  LowestDimension:=min(LowestDimension,StatMat[op(T)][1]*StatMat[op(T)][2]);
  if TravIns[1][op(T)]<>"finished" and StatMat[op(TravIns[1][op(T)])]=0 then
   TravIns[1][op(T)]:=TravIns[1][op(TravIns[1][op(T)])]:
  else
   T:=TravIns[1][op(T)];
  fi;
 od:
 return NULL;
end proc:

assign_OM:=proc(numDimsToPrint:=2)
 #automatically runs rectify_TravIns_find_LD beforehand
 global StatMat,TravIns,LowestDimension,OM,calcToDimension;
 local T,L,i;
 rectify_TravIns_find_LD();
 L:=[];
 T:=TravIns[2];
 while T<>"finished" do
  if StatMat[op(T)][1]*StatMat[op(T)][2] <= LowestDimension+numDimsToPrint-1 then
   L:=[op(L),T];
  fi;
  T:=TravIns[1][op(T)];
 od;
 #L:=map(x->[x,remove(y->y=[],[seq(RL[i][x[i]],i=1..nops(x))]),op(StatMat[op(x)])],L);
 L:=map(x->[x,remove(y->y=[],[seq(RL[i][x[i]],i=1..nops(x))]),op(StatMat[op(x)]),StatMat[op(x)][1]*StatMat[op(x)][2],
            2^(add(nops(RL[i][x[i]]),i=1..nops(x)-1))*StatMat[op(x)][1]*(dValue+1+nops(RL[-1][x[-1]])+add(RL[-1][x[-1]][j]*(2^j-1),j=1..nops(RL[-1][x[-1]])))-1   ],L);
 #[1=location,2=printout,3=power,4=dimensionOfFirstPower,5=t-s,6=t]
 L:=map(x->[op(x),x[6]-x[5],PrettyPrintPRelt([[x[3],x[2]]])   ,   E2DegreePRHomEltNoZero(unExcessFormatPR([[x[3],x[2]]]),dValue)],L);
 #[...,7=s,8=prettyprint,9=allE2dimensions(forDebug)]
 L:=sort(L,(x,y)->(x[5]<y[5] or 
                           (x[5]=y[5] and x[6]<y[6])) or
                           (x[5]=y[5] and x[6]=y[6] and
  lexorder(StringTools[Reverse](convert(ListTools[Flatten](x[2]),string)),
           StringTools[Reverse](convert(ListTools[Flatten](y[2]),string)))
                            )):
 for i to nops(L) do
  L[i]:=[op(L[i]),i];
 od;
 L:=[['loc',`elt`,`pow`,`1powDim`,`t-s`,`t`,`s`,`elt`,`dims`,` `],op(L)];
 OM:=Matrix(L);
 if nops(L)>1 then
  timed_message("OM has ",nops(L)-1," entries, starting in dimension ",L[2][5]);
 else
  timed_message("spectral sequence cleared up to dimension ",calcToDimension);
 fi;
 return NULL;
end proc:

print_OM:=proc(outputVector:=[10,1,2,3,8,7,5])
 global OM;
 print(LinearAlgebra[SubMatrix](OM,[1..-1],outputVector));
end proc:

assign_and_print_OM:=proc(numDimsToPrint:=2,outputVector:=[10,1,2,3,8,7,5])
 assign_OM(numDimsToPrint);
 print_OM(outputVector);
end proc:

diff_extractor:=proc(TR,SR,outputVector:=[10,1,2,3,8,7,5])
 global OM;
 print(LinearAlgebra[SubMatrix](OM,[1,TR+1,SR+1],outputVector));
 #why not test somthing at this point?
 [`?`,cat("d",OM[TR+1,7]-OM[SR+1,7]),OM[SR+1,2],OM[SR+1,3],OM[TR+1,2],OM[TR+1,3],OM[SR+1,1],OM[TR+1,1]];
end proc:

trim_off_Einfty_classes:=proc()
 global StatMat,TravIns,dValue,RL;
 local i;
 kill_class([seq(1,i=1..nops(RL))]);
 for i from 2 to nops(RL[-1]) do
  if remove(x->x=0,RL[-1][i])=[dValue] and RL[-1][i][-1]=dValue then
   double_class([seq(1,i=1..nops(RL)-1),i]);  
  fi;
 od;
 timed_message("trimmed off the E_infinity classes");
 return NULL;
end proc:

implement_diff:=proc(difl,logFlag:=true)
 global RL,StatMat;
 if nops(StatMat[op(difl[7])])<>2 or nops(StatMat[op(difl[8])])<>2 then
  error "either source or target is already dead or broken";
 fi;
 if difl[4]<>StatMat[op(difl[7])][1] then
  error "the source power is wrong";
 fi;
 if difl[6]<>StatMat[op(difl[8])][1] then
  error "the target power is likely to be wrong";
 fi;
 kill_class(difl[8]);
 double_class(difl[7]);
 if logFlag=false then return NULL; fi;
 if outputStreamOpenFlag=0 then
  reopen_dlog();
  timed_message("(in order to store differentials)");
 elif outputStreamOpenFlag<>1 then
  new_dlog();
  timed_message("(in order to store differentials)");
 fi;
 dlog(difl);
 return NULL;
end proc:

differential_coords_finder:=proc(diff,sEqualityPositions:=false,tEqualityPositions:=false)
 #will find the coordinates of the elements in a differential if they are missing
 #if coordinates are present, will automatically refind them unless passed "done" or "same"
 #if partially incorrect coordinates present, will correct them - can be passed a short list...
 #...of negative integer indices where the corrdinates given are known.
 local output;
 output:=diff[1..6];
 if sEqualityPositions="no hints" or sEqualityPositions=false then
  output:=[op(output),find_RL_coordinates(diff[3])];
 elif sEqualityPositions="same" or sEqualityPositions="done" then
  output:=[op(output),diff[7]];
 else
  output:=[op(output),find_RL_coordinates_with_hints(diff[3],
                 map(x->[x,diff[7][x]],sEqualityPositions))];
 fi;
 if tEqualityPositions="no hints" or tEqualityPositions=false then
  output:=[op(output),find_RL_coordinates(diff[5])];
 elif tEqualityPositions="same" or tEqualityPositions="done" then
  output:=[op(output),diff[8]];
 else
  output:=[op(output),find_RL_coordinates_with_hints(diff[5],
                 map(x->[x,diff[8][x]],tEqualityPositions))];
 fi;
 return output;
end proc:

double_rMinusOne:=proc(dwhat)
 option remember;
 local SR;
 if not type("hi",'string') then error "not a string" fi;
 SR:=StringTools[SelectRemove]( StringTools[IsDigit],  dwhat  );
 if SR[2]<>"d" or dwhat[1]<>"d" then error "not of form d123" fi;
 SR[1];
 cat("d",2*parse(%)-1);
end proc:

differential_upgrader:=proc(diff,sDescriptor,sData,tDescriptor,tData)
 #under construction
 local output;
 output:=diff;
 if sDescriptor="square" then
  output[4]:=2*output[4];
 elif sDescriptor="add new sequence" then
  output[3]:=[sData,op(output[3])];
 elif sDescriptor="append to left of leftmost nontrivial sequence" then
  output[3]:=remove(x->x=[],output[3]);
  output[3][1]:=[op(sData),op(output[3][1])]
 elif sDescriptor="completely replace, inputting [srcS,pow]" then
 fi;
end proc;

first_round_of_differentials:=proc(logFlag:=true)
 global RL,StatMat,dValue,outputStreamOpenFlag;
 local ell1,exc1,a,i,srcI1,trgS,srcPow,trgPow,difl,srcCoords,trgCoords,diffCounter;
 timed_message("starting first round of differentials");
 diffCounter:=0;
 for i from 2 to nops(RL[-1]) do
  srcPow:=1;
  srcCoords:=[seq(1,i=1..nops(RL)-1),i];
  srcI1:=RL[-1][i];
  if remove(x->x=0,srcI1)<>[dValue] and StatMat[op(srcCoords)]<>0 then
   ell1:=nops(srcI1);
   exc1:=add(srcI1[gh],gh=1..ell1);
   a:=dValue+ell1-exc1;
   if a<ell1-1 and a>=1 then
    trgS:=[[a],srcI1[2..-1]];
    trgPow:=1;
   elif a=ell1-1 then
    trgS:=[srcI1[2..-1]];
    trgPow:=2;
   else
    error "this is strange";
   fi;
   trgCoords:=find_RL_coordinates(trgS);
   difl:=[`rnd1`,cat("d",a),[srcI1],srcPow,trgS,trgPow,srcCoords,trgCoords];
   if trgPow=2 and trgCoords<>0 and StatMat[op(trgCoords)]<>0 then
    implement_diff(difl,logFlag);diffCounter:=diffCounter+1;
   elif trgPow=1 then
    while StatMat[op(srcCoords)]<>0 and trgCoords<>0 and StatMat[op(trgCoords)]<>0 do
     implement_diff(difl,logFlag);diffCounter:=diffCounter+1;
     trgS:=[[0],op(trgS)];
     srcPow:=2*srcPow;
     trgCoords:=find_RL_coordinates(trgS);
     a:=2*a-1;
     difl:=[`rnd1`,cat("d",a),[srcI1],srcPow,trgS,trgPow,srcCoords,trgCoords];
    od;
   fi;
  fi;
 od;
 timed_message("finished first round of differentials - there were ",diffCounter);
 return NULL;
end proc:

second_round_of_differentials:=proc(logFlag:=true)
 global RL,StatMat,dValue,outputStreamOpenFlag;
 local ell1,exc1,jay,i,srcI1,srcS,trgS,srcPow,trgPow,difl,srcCoords,trgCoords,diffCounter;
 timed_message("starting second round of differentials");
 diffCounter:=0;
 for i from 2 to nops(RL[-1]) do
 srcI1:=RL[-1][i];
 ell1:=nops(srcI1);
 exc1:=add(srcI1[gh],gh=1..ell1); 
 for jay from 2+dValue+ell1-exc1 to ell1-1 do
  srcS:=[[jay],srcI1];
  srcCoords:=find_RL_coordinates_with_hints(srcS,[[-1,i]]);
  trgS:=[[jay-1-(dValue+ell1-exc1),dValue+ell1-exc1],srcI1[2..-1]];
  trgCoords:=find_RL_coordinates(trgS);
  srcPow:=1;
  trgPow:=1;
  if srcCoords<>0 and StatMat[op(srcCoords)]<>0 and trgCoords<>0 and StatMat[op(trgCoords)]<>0 then
   difl:=[`rnd2`,cat("d",2*(dValue+ell1-exc1)-1),srcS,srcPow,trgS,trgPow,srcCoords,trgCoords];
#   if trgPow=2 and trgCoords<>0 and StatMat[op(trgCoords)]<>0 then
    implement_diff(difl,logFlag);diffCounter:=diffCounter+1;
#   elif trgPow=1 then
#    while StatMat[op(srcCoords)]<>0 and trgCoords<>0 and StatMat[op(trgCoords)]<>0 do
#     implement_diff(difl,logFlag);diffCounter:=diffCounter+1;
#     trgS:=[[0],op(trgS)];
#     srcPow:=2*srcPow;
#     trgCoords:=find_RL_coordinates(trgS);
#     a:=2*a-1;
#     difl:=[`rnd1`,cat("d",a),[srcI1],srcPow,trgS,trgPow,srcCoords,trgCoords];
#    od;
#   fi;
  fi;
 od;od;
 timed_message("finished 2nd round of differentials - there were ",diffCounter);
 return NULL;
end proc:


########### begin program
set_dimensions(500,2);
build_RL();
build_StatMat_TravIns();
trim_off_Einfty_classes();
assign_and_print_OM();
first_round_of_differentials();
close_dlog();
assign_and_print_OM();
#diff_extractor(1,2);
second_round_of_differentials();
assign_and_print_OM();
close_dlog();
